<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flight Sim — Phase 5</title>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    color: #0f0;
    font-family: 'Courier New', monospace;
    overflow: hidden;
    height: 100vh;
  }
  #renderCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
    outline: none;
  }
  #hud {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 10;
    pointer-events: none;
    background: rgba(0, 0, 0, 0.85);
    border: 1px solid #0f0;
    padding: 24px 32px;
    border-radius: 8px;
    font-size: 16px;
    line-height: 1.8;
    min-width: 340px;
  }
  #hud h2 {
    text-align: center;
    margin-bottom: 12px;
    font-size: 18px;
    border-bottom: 1px solid #0a0;
    padding-bottom: 8px;
  }
  .row { display: flex; justify-content: space-between; }
  .label { color: #0a0; }
  .value { color: #0f0; font-weight: bold; }
  .stall {
    text-align: center;
    margin-top: 12px;
    font-size: 20px;
    font-weight: bold;
    color: #f00;
    visibility: hidden;
  }
  .stall.active { visibility: visible; animation: blink 0.3s infinite; }
  @keyframes blink { 50% { opacity: 0; } }

  /* Artificial Horizon */
  #horizon-container {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    overflow: hidden;
    border: 2px solid #0f0;
    margin: 12px auto;
    position: relative;
    background: #111;
  }
  #horizon-ball {
    width: 100%;
    height: 300px;
    position: absolute;
    top: 50%;
    left: 0;
    margin-top: -150px;
    transform-origin: center 150px;
  }
  #horizon-sky {
    width: 100%;
    height: 150px;
    background: linear-gradient(to bottom, #1a3a6a, #3a7abf);
  }
  #horizon-ground {
    width: 100%;
    height: 150px;
    background: linear-gradient(to bottom, #7a5c2e, #4a3518);
  }
  #horizon-line {
    position: absolute;
    top: 150px;
    left: 0;
    width: 100%;
    height: 1px;
    background: #fff;
  }
  .pitch-mark {
    position: absolute;
    left: 50%;
    height: 1px;
    background: rgba(255, 255, 255, 0.6);
  }
  .pitch-mark.deg10 { width: 30px; margin-left: -15px; }
  .pitch-mark.deg20 { width: 50px; margin-left: -25px; }
  .pitch-mark.up10 { top: 135px; }
  .pitch-mark.up20 { top: 120px; }
  .pitch-mark.dn10 { top: 165px; }
  .pitch-mark.dn20 { top: 180px; }
  #horizon-wings {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
  }
  #horizon-wings::before,
  #horizon-wings::after {
    content: '';
    position: absolute;
    top: -1px;
    height: 3px;
    width: 25px;
    background: #f80;
  }
  #horizon-wings::before { right: 8px; }
  #horizon-wings::after { left: 8px; }
  #horizon-dot {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 6px;
    height: 6px;
    margin: -3px 0 0 -3px;
    background: #f80;
    border-radius: 50%;
    z-index: 2;
  }

  /* Throttle Bar */
  #hud-instruments {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    margin: 8px 0;
  }
  #throttle-bar {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }
  #throttle-track {
    width: 20px;
    height: 120px;
    border: 1px solid #0f0;
    position: relative;
    border-radius: 3px;
    overflow: hidden;
  }
  #throttle-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background: linear-gradient(to top, #0a0, #0f0);
    transition: height 0.05s linear;
  }
  #throttle-label {
    font-size: 10px;
    color: #0a0;
    letter-spacing: 1px;
  }
  /* Crash overlay */
  #crash-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 20;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Courier New', monospace;
  }
  #crash-overlay.visible { display: flex; }
  #crash-overlay .crash-title {
    font-size: 64px;
    font-weight: bold;
    color: #f00;
    text-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
    margin-bottom: 20px;
  }
  #crash-overlay .crash-subtitle {
    font-size: 20px;
    color: #ccc;
  }

  /* Pause overlay */
  #pause-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 20;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Courier New', monospace;
  }
  #pause-overlay.visible { display: flex; }
  #pause-overlay .pause-title {
    font-size: 48px;
    font-weight: bold;
    color: #fff;
    margin-bottom: 16px;
  }
  #pause-overlay .pause-subtitle {
    font-size: 18px;
    color: #aaa;
  }

  /* Ground state indicator */
  .state-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 3px;
    font-size: 12px;
    font-weight: bold;
    letter-spacing: 1px;
  }
  .state-badge.gnd { background: #553300; color: #ffaa00; }
  .state-badge.air { background: #003355; color: #00aaff; }

  #controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: #0a0;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    text-align: center;
    opacity: 0.7;
  }
</style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<div id="hud">
  <h2>FLIGHT DATA</h2>
  <div class="row"><span class="label">MSL Alt</span><span class="value" id="alt">0 ft</span></div>
  <div class="row"><span class="label">AGL</span><span class="value" id="agl">0 ft</span></div>
  <div class="row"><span class="label">Airspeed</span><span class="value" id="spd">0 kt</span></div>
  <div class="row"><span class="label">Vert Speed</span><span class="value" id="vs">0 fpm</span></div>
  <div class="row"><span class="label">Pitch</span><span class="value" id="pitch">0°</span></div>
  <div class="row"><span class="label">Roll</span><span class="value" id="roll">0°</span></div>
  <div class="row"><span class="label">Heading</span><span class="value" id="hdg">0°</span></div>
  <div class="row"><span class="label">State</span><span class="value" id="flight-state"><span class="state-badge gnd">GND</span></span></div>

  <div id="hud-instruments">
    <div id="horizon-container">
      <div id="horizon-ball">
        <div id="horizon-sky"></div>
        <div id="horizon-ground"></div>
        <div id="horizon-line"></div>
        <div class="pitch-mark deg10 up10"></div>
        <div class="pitch-mark deg20 up20"></div>
        <div class="pitch-mark deg10 dn10"></div>
        <div class="pitch-mark deg20 dn20"></div>
      </div>
      <div id="horizon-wings"></div>
      <div id="horizon-dot"></div>
    </div>
    <div id="throttle-bar">
      <div id="throttle-track">
        <div id="throttle-fill"></div>
      </div>
      <div id="throttle-label">THR</div>
    </div>
  </div>

  <div class="row"><span class="label">Throttle</span><span class="value" id="thr">0%</span></div>
  <div class="row"><span class="label">AoA</span><span class="value" id="aoa">0°</span></div>
  <div class="stall" id="stall">!! STALL !!</div>
</div>

<div id="controls">
  ↑↓ Pitch &nbsp;|&nbsp; ←→ Roll &nbsp;|&nbsp; A/D Yaw &nbsp;|&nbsp; W/S Throttle &nbsp;|&nbsp; P Pause
</div>

<div id="crash-overlay">
  <div class="crash-title">CRASHED</div>
  <div class="crash-subtitle">Press R to restart</div>
</div>

<div id="pause-overlay">
  <div class="pause-title">PAUSED</div>
  <div class="pause-subtitle">Press P to resume</div>
</div>

<script>
// ============================================================
// Vector3 — minimal 3D vector math
// ============================================================
class Vec3 {
  constructor(x = 0, y = 0, z = 0) { this.x = x; this.y = y; this.z = z; }
  set(x, y, z) { this.x = x; this.y = y; this.z = z; return this; }
  copy(v) { this.x = v.x; this.y = v.y; this.z = v.z; return this; }
  clone() { return new Vec3(this.x, this.y, this.z); }
  add(v) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
  sub(v) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
  scale(s) { return new Vec3(this.x * s, this.y * s, this.z * s); }
  addScaled(v, s) { return new Vec3(this.x + v.x * s, this.y + v.y * s, this.z + v.z * s); }
  dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
  cross(v) {
    return new Vec3(
      this.y * v.z - this.z * v.y,
      this.z * v.x - this.x * v.z,
      this.x * v.y - this.y * v.x
    );
  }
  length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }
  lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z; }
  normalize() {
    const len = this.length();
    if (len < 1e-10) return new Vec3(0, 0, 0);
    return this.scale(1 / len);
  }
}

// ============================================================
// Quaternion — orientation math
// ============================================================
class Quat {
  constructor(x = 0, y = 0, z = 0, w = 1) { this.x = x; this.y = y; this.z = z; this.w = w; }
  clone() { return new Quat(this.x, this.y, this.z, this.w); }

  multiply(q) {
    return new Quat(
      this.w * q.x + this.x * q.w + this.y * q.z - this.z * q.y,
      this.w * q.y - this.x * q.z + this.y * q.w + this.z * q.x,
      this.w * q.z + this.x * q.y - this.y * q.x + this.z * q.w,
      this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z
    );
  }

  normalize() {
    const len = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    if (len < 1e-10) return new Quat(0, 0, 0, 1);
    return new Quat(this.x / len, this.y / len, this.z / len, this.w / len);
  }

  // Rotate a vector by this quaternion: q * v * q^-1
  rotateVec(v) {
    const qv = new Quat(v.x, v.y, v.z, 0);
    const qConj = new Quat(-this.x, -this.y, -this.z, this.w);
    const result = this.multiply(qv).multiply(qConj);
    return new Vec3(result.x, result.y, result.z);
  }

  // Create quaternion from axis-angle
  static fromAxisAngle(axis, angle) {
    const half = angle * 0.5;
    const s = Math.sin(half);
    return new Quat(axis.x * s, axis.y * s, axis.z * s, Math.cos(half));
  }

  // Extract euler angles (pitch, yaw, roll) for display only
  toEuler() {
    const sinr = 2 * (this.w * this.x + this.y * this.z);
    const cosr = 1 - 2 * (this.x * this.x + this.y * this.y);
    const roll = Math.atan2(sinr, cosr);

    const sinp = 2 * (this.w * this.y - this.z * this.x);
    const pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * Math.PI / 2 : Math.asin(sinp);

    const siny = 2 * (this.w * this.z + this.x * this.y);
    const cosy = 1 - 2 * (this.y * this.y + this.z * this.z);
    const yaw = Math.atan2(siny, cosy);

    return { pitch, roll, yaw };
  }
}

// ============================================================
// SimplexNoise — 2D simplex noise (Stefan Gustavson algorithm)
// ============================================================
class SimplexNoise {
  constructor(seed = 0) {
    this.grad3 = [
      [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
      [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
      [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
    ];
    const p = new Uint8Array(256);
    // Simple seeded PRNG
    let s = seed;
    for (let i = 0; i < 256; i++) {
      s = (s * 16807 + 0) % 2147483647;
      p[i] = s & 255;
    }
    this.perm = new Uint8Array(512);
    this.permMod12 = new Uint8Array(512);
    for (let i = 0; i < 512; i++) {
      this.perm[i] = p[i & 255];
      this.permMod12[i] = this.perm[i] % 12;
    }
  }

  noise2D(x, y) {
    const F2 = 0.5 * (Math.sqrt(3) - 1);
    const G2 = (3 - Math.sqrt(3)) / 6;
    const s = (x + y) * F2;
    const i = Math.floor(x + s);
    const j = Math.floor(y + s);
    const t = (i + j) * G2;
    const X0 = i - t, Y0 = j - t;
    const x0 = x - X0, y0 = y - Y0;
    let i1, j1;
    if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
    const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
    const x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
    const ii = i & 255, jj = j & 255;
    const gi0 = this.permMod12[ii + this.perm[jj]];
    const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];
    const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];
    let n0 = 0, n1 = 0, n2 = 0;
    let t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 >= 0) { t0 *= t0; n0 = t0 * t0 * (this.grad3[gi0][0] * x0 + this.grad3[gi0][1] * y0); }
    let t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 >= 0) { t1 *= t1; n1 = t1 * t1 * (this.grad3[gi1][0] * x1 + this.grad3[gi1][1] * y1); }
    let t2 = 0.5 - x2 * x2 - y2 * y2;
    if (t2 >= 0) { t2 *= t2; n2 = t2 * t2 * (this.grad3[gi2][0] * x2 + this.grad3[gi2][1] * y2); }
    return 70 * (n0 + n1 + n2); // returns [-1, 1]
  }
}

// ============================================================
// Terrain Height Function — source of truth for physics & visuals
// ============================================================
const simplex = new SimplexNoise(42);
const TERRAIN_SIZE = 10000;
const TERRAIN_MAX_HEIGHT = 600;

function getTerrainHeight(x, z) {
  // Flat zone for runway: |x| < 40 AND z in [-850, 50]
  if (Math.abs(x) < 40 && z > -850 && z < 50) return 0;

  // Wide flat airfield zone (600m) with gentle transition out to 1500m
  const dist = Math.sqrt(x * x + z * z);
  if (dist < 600) return 0;
  let flattenFactor = 1.0;
  if (dist < 1500) {
    const t = (dist - 600) / 900;
    flattenFactor = t * t * (3 - 2 * t); // smoothstep
  }

  // 4-octave fBm simplex noise
  const scale = 1 / 1200; // base frequency
  let amplitude = 1.0;
  let frequency = 1.0;
  let total = 0;
  let maxAmp = 0;
  for (let o = 0; o < 4; o++) {
    total += amplitude * simplex.noise2D(x * scale * frequency, z * scale * frequency);
    maxAmp += amplitude;
    amplitude *= 0.5;
    frequency *= 2.0;
  }

  // Normalize to [0, 1] then scale
  const normalized = (total / maxAmp + 1) * 0.5; // [-1,1] -> [0,1]
  const height = normalized * TERRAIN_MAX_HEIGHT * flattenFactor;
  return Math.max(0, height);
}

// ============================================================
// FlightModel — core physics
// ============================================================
class FlightModel {
  constructor() {
    // --- Aircraft constants ---
    this.mass = 1000;             // kg — light aircraft
    this.maxThrust = 5000;        // N — light prop aircraft (~30% throttle = level at 70 m/s)
    this.wingArea = 16;           // m² — wing reference area
    this.airDensity = 1.225;      // kg/m³ — sea level ISA

    // Lift
    this.clSlope = 5.5;           // CL per radian — typical for small wings (2π ≈ 6.28 theoretical)
    this.stallAngle = 15 * Math.PI / 180; // ~15° stall angle
    this.postStallFactor = 0.4;   // CL multiplier after stall (lift drops to 40%)

    // Drag
    this.cd0 = 0.03;              // parasitic drag coefficient (clean light aircraft)
    this.cdInducedK = 0.06;       // induced drag factor: CD_induced = K * CL²
    this.cdStall = 0.15;          // extra drag added during stall

    // Control authority — torque per unit input per unit dynamic pressure
    this.pitchAuthority = 0.6;    // pitch torque sensitivity (~10°/s at cruise speed)
    this.rollAuthority = 2.0;     // roll torque sensitivity
    this.yawAuthority = 0.4;      // yaw torque sensitivity

    // Damping — angular velocity decay rate (1/s), higher = more stable
    this.pitchDamping = 3.0;
    this.rollDamping = 3.0;
    this.yawDamping = 2.5;

    // Stability
    this.trimAoA = 2 * Math.PI / 180; // 2° — AoA for hands-off level flight
    this.pitchStability = 0.5;    // restoring torque toward trimAoA (not zero)
    this.weathervaneStrength = 1.5; // yaw correction from sideslip
    this.dihedralStrength = 1.5;  // restoring roll from bank angle (dihedral effect)
    this.sideslipForce = 500;     // lateral force resisting sideslip (N per m/s)

    // Ground physics
    this.groundFriction = 0.03;     // rolling friction coefficient (tires on asphalt)
    this.takeoffSpeed = 60;         // m/s — minimum speed for takeoff
    this.noseWheelSteer = 0.8;      // yaw rate on ground (rad/s at full input)

    // Terrain callback — injected externally
    this.getGroundHeight = (x, z) => 0;

    // --- State ---
    this.reset();
  }

  reset() {
    this.position = new Vec3(0, 0, 0);          // on the runway
    this.velocity = new Vec3(0, 0, 0);          // stationary
    this.orientation = new Quat(0, 0, 0, 1);   // identity — level, facing -Z
    this.angularVelocity = new Vec3(0, 0, 0);   // rad/s in body frame

    this.throttle = 0;
    this.airspeed = 0;
    this.altitude = 0;
    this.verticalSpeed = 0;
    this.aoa = 0;
    this.isStalling = false;

    this.groundHeight = 0;
    this.agl = 0;

    this.onGround = true;
    this.crashed = false;

    // Inputs (set externally each frame)
    this.pitchInput = 0;   // -1 to 1
    this.rollInput = 0;    // -1 to 1
    this.yawInput = 0;     // -1 to 1
  }

  // Get aircraft's local axes in world space
  getForward() { return this.orientation.rotateVec(new Vec3(0, 0, -1)); }
  getUp()      { return this.orientation.rotateVec(new Vec3(0, 1, 0)); }
  getRight()   { return this.orientation.rotateVec(new Vec3(1, 0, 0)); }

  stepPhysics(dt) {
    if (this.crashed) return;

    const forward = this.getForward();
    const up = this.getUp();
    const right = this.getRight();

    // --- Airspeed & dynamic pressure ---
    this.airspeed = this.velocity.length();
    const dynamicPressure = 0.5 * this.airDensity * this.airspeed * this.airspeed;
    const qS = dynamicPressure * this.wingArea;

    // =============================================
    // GROUND MODE
    // =============================================
    if (this.onGround) {
      // Thrust along forward axis (taxi)
      const thrustMag = this.throttle * this.maxThrust;
      let totalForce = forward.scale(thrustMag);

      // Aerodynamic drag (still applies on ground)
      if (this.airspeed > 0.5) {
        const cd = this.cd0;
        const dragMag = cd * qS;
        const dragDir = this.velocity.normalize().scale(-1);
        totalForce = totalForce.add(dragDir.scale(dragMag));
      }

      // Ground friction — constant force opposing motion (rolling friction = μ * weight)
      if (this.airspeed > 0.1) {
        const frictionMag = this.groundFriction * this.mass * 9.81;
        const frictionForce = this.velocity.normalize().scale(-frictionMag);
        totalForce = totalForce.add(frictionForce);
      }

      // Acceleration
      const accel = totalForce.scale(1 / this.mass);
      this.velocity = this.velocity.add(accel.scale(dt));

      // Nose wheel steering — yaw proportional to input and speed
      if (this.airspeed > 0.5) {
        const steerRate = this.yawInput * this.noseWheelSteer;
        // Scale steering down at high speed for realism
        const speedFactor = Math.min(1, 10 / this.airspeed);
        const yawAngle = steerRate * speedFactor * dt;
        const yawQ = Quat.fromAxisAngle(new Vec3(0, 1, 0), yawAngle);
        this.orientation = yawQ.multiply(this.orientation).normalize();
        // Also rotate velocity to follow heading
        this.velocity = yawQ.rotateVec(this.velocity);
      }

      // Constrain orientation — force level (no roll, no pitch)
      // Rebuild quaternion from yaw only
      const fwd = this.getForward();
      const yaw = Math.atan2(fwd.x, -fwd.z);
      this.orientation = Quat.fromAxisAngle(new Vec3(0, 1, 0), yaw);

      // Kill angular velocity on ground
      this.angularVelocity.set(0, 0, 0);

      // Clamp to ground (terrain-relative)
      this.groundHeight = this.getGroundHeight(this.position.x, this.position.z);
      this.position.y = this.groundHeight;
      this.velocity.y = 0;

      // Update position
      this.position = this.position.add(this.velocity.scale(dt));
      this.groundHeight = this.getGroundHeight(this.position.x, this.position.z);
      this.position.y = this.groundHeight; // enforce after position update

      // Stop completely at very low speed with no throttle
      if (this.airspeed < 0.5 && this.throttle < 0.01) {
        this.velocity.set(0, 0, 0);
      }

      // Takeoff condition: speed > threshold AND pulling back on stick
      if (this.airspeed > this.takeoffSpeed && this.pitchInput > 0) {
        this.onGround = false;
        // Give slight upward pitch to generate lift
        const fwd2 = this.getForward();
        const yaw2 = Math.atan2(fwd2.x, -fwd2.z);
        const pitchUp = 5 * Math.PI / 180; // 5° nose up on takeoff
        this.orientation = Quat.fromAxisAngle(new Vec3(0, 1, 0), yaw2)
          .multiply(Quat.fromAxisAngle(new Vec3(1, 0, 0), pitchUp));
      }

      // AoA is zero on ground
      this.aoa = 0;
      this.isStalling = false;

      // Update derived values
      this.altitude = this.position.y;
      this.agl = this.position.y - this.groundHeight;
      this.verticalSpeed = 0;
      return;
    }

    // =============================================
    // FLIGHT MODE (existing physics)
    // =============================================

    // --- Angle of Attack ---
    if (this.airspeed > 0.5) {
      const velNorm = this.velocity.normalize();
      const forwardDot = velNorm.dot(forward);
      const upDot = velNorm.dot(up);
      this.aoa = Math.atan2(-upDot, forwardDot);
    } else {
      this.aoa = 0;
    }

    // --- Unified CL ---
    let cl;
    const absAoa = Math.abs(this.aoa);
    if (absAoa < this.stallAngle) {
      cl = this.clSlope * this.aoa;
      this.isStalling = false;
    } else {
      cl = this.clSlope * Math.sign(this.aoa) * this.stallAngle * this.postStallFactor;
      this.isStalling = true;
    }

    // --- Forces ---
    let totalForce = new Vec3(0, 0, 0);

    // 1. Gravity
    totalForce = totalForce.add(new Vec3(0, -9.81 * this.mass, 0));

    // 2. Thrust
    const thrustMag = this.throttle * this.maxThrust;
    totalForce = totalForce.add(forward.scale(thrustMag));

    // 3. Lift
    if (this.airspeed > 1) {
      const liftMag = cl * qS;
      const velDir = this.velocity.normalize();
      let liftDir = velDir.cross(right).normalize();
      if (liftDir.dot(up) < 0) liftDir = liftDir.scale(-1);
      totalForce = totalForce.add(liftDir.scale(liftMag));
    }

    // 4. Drag
    if (this.airspeed > 0.5) {
      const cdInduced = this.cdInducedK * cl * cl;
      let cd = this.cd0 + cdInduced;
      if (this.isStalling) cd += this.cdStall;
      const dragMag = cd * qS;
      const dragDir = this.velocity.normalize().scale(-1);
      totalForce = totalForce.add(dragDir.scale(dragMag));
    }

    // 5. Sideslip force
    if (this.airspeed > 1) {
      const velDir = this.velocity.normalize();
      const sideslip = velDir.dot(right);
      const sideslipForce = right.scale(-sideslip * this.sideslipForce * this.airspeed);
      totalForce = totalForce.add(sideslipForce);
    }

    // --- Acceleration ---
    const accel = totalForce.scale(1 / this.mass);
    this.velocity = this.velocity.add(accel.scale(dt));

    // --- Torques ---
    const authorityScale = Math.min(dynamicPressure / 3000, 1.5);

    const pitchTorque = this.pitchInput * this.pitchAuthority * authorityScale;
    const rollTorque = -this.rollInput * this.rollAuthority * authorityScale;
    let yawTorque = -this.yawInput * this.yawAuthority * authorityScale;

    const pitchStab = -(this.aoa - this.trimAoA) * this.pitchStability * authorityScale;

    if (this.airspeed > 1) {
      const velDir = this.velocity.normalize();
      const sideslip = Math.asin(Math.max(-1, Math.min(1, velDir.dot(right))));
      yawTorque += -sideslip * this.weathervaneStrength * authorityScale;
    }

    const worldUp = new Vec3(0, 1, 0);
    const bankDot = right.dot(worldUp);
    const dihedralTorque = -bankDot * this.dihedralStrength * authorityScale;

    this.angularVelocity.x += (pitchTorque + pitchStab) * dt;
    this.angularVelocity.y += yawTorque * dt;
    this.angularVelocity.z += (rollTorque + dihedralTorque) * dt;

    this.angularVelocity.x *= Math.exp(-this.pitchDamping * dt);
    this.angularVelocity.y *= Math.exp(-this.yawDamping * dt);
    this.angularVelocity.z *= Math.exp(-this.rollDamping * dt);

    const maxAngVel = 3.0;
    this.angularVelocity.x = Math.max(-maxAngVel, Math.min(maxAngVel, this.angularVelocity.x));
    this.angularVelocity.y = Math.max(-maxAngVel, Math.min(maxAngVel, this.angularVelocity.y));
    this.angularVelocity.z = Math.max(-maxAngVel, Math.min(maxAngVel, this.angularVelocity.z));

    // --- Apply rotation ---
    const omega = new Quat(
      this.angularVelocity.x,
      this.angularVelocity.y,
      this.angularVelocity.z,
      0
    );
    const qDot = this.orientation.multiply(omega);
    this.orientation = new Quat(
      this.orientation.x + qDot.x * 0.5 * dt,
      this.orientation.y + qDot.y * 0.5 * dt,
      this.orientation.z + qDot.z * 0.5 * dt,
      this.orientation.w + qDot.w * 0.5 * dt
    ).normalize();

    // --- Update position ---
    this.position = this.position.add(this.velocity.scale(dt));

    // --- Landing / Crash Detection (terrain-relative) ---
    this.groundHeight = this.getGroundHeight(this.position.x, this.position.z);
    if (this.position.y <= this.groundHeight) {
      const descentRate = -this.velocity.y; // positive = descending
      const fwd = this.getForward();
      const rt = this.getRight();
      const u = this.getUp();
      const pitchDeg = Math.asin(Math.max(-1, Math.min(1, fwd.y))) * 180 / Math.PI;
      const rollDeg = Math.atan2(-rt.dot(new Vec3(0, 1, 0)), u.dot(new Vec3(0, 1, 0))) * 180 / Math.PI;

      if (descentRate < 3 && Math.abs(pitchDeg) < 15 && Math.abs(rollDeg) < 30) {
        // Safe landing
        this.onGround = true;
        this.position.y = this.groundHeight;
        this.velocity.y = 0;
        this.angularVelocity.set(0, 0, 0);
        // Rebuild orientation from yaw only (level the aircraft, preserve heading)
        const yaw = Math.atan2(fwd.x, -fwd.z);
        this.orientation = Quat.fromAxisAngle(new Vec3(0, 1, 0), yaw);
      } else {
        // Crash
        this.crashed = true;
        this.position.y = this.groundHeight;
        this.velocity.set(0, 0, 0);
        this.angularVelocity.set(0, 0, 0);
      }
    }

    // --- Velocity clamp ---
    const maxSpeed = 300;
    if (this.airspeed > maxSpeed) {
      this.velocity = this.velocity.normalize().scale(maxSpeed);
    }

    // --- Update derived values ---
    this.altitude = this.position.y;
    this.agl = this.position.y - this.groundHeight;
    this.verticalSpeed = this.velocity.y;
  }
}

// ============================================================
// Input Handler — keyboard with smoothing
// ============================================================
class InputHandler {
  constructor() {
    this.keys = {};
    this.smoothPitch = 0;
    this.smoothRoll = 0;
    this.smoothYaw = 0;
    this.rampRate = 5.0; // ramp toward target at 5/s

    window.addEventListener('keydown', (e) => {
      this.keys[e.code] = true;
      e.preventDefault();
    });
    window.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
      e.preventDefault();
    });
  }

  update(dt, model) {
    // Raw target inputs
    let targetPitch = 0;
    let targetRoll = 0;
    let targetYaw = 0;

    if (this.keys['ArrowUp'])    targetPitch = -1; // push forward = nose down
    if (this.keys['ArrowDown'])  targetPitch =  1; // pull back = nose up
    if (this.keys['ArrowLeft'])  targetRoll  = -1; // roll left
    if (this.keys['ArrowRight']) targetRoll  =  1; // roll right
    if (this.keys['KeyA'])       targetYaw   = -1; // yaw left
    if (this.keys['KeyD'])       targetYaw   =  1; // yaw right

    // Throttle — adjust and clamp (persists)
    const throttleRate = 0.5; // 0 to 1 in 2 seconds
    if (this.keys['KeyW']) model.throttle = Math.min(1, model.throttle + throttleRate * dt);
    if (this.keys['KeyS']) model.throttle = Math.max(0, model.throttle - throttleRate * dt);

    // Smooth ramp toward targets
    this.smoothPitch = this._ramp(this.smoothPitch, targetPitch, dt);
    this.smoothRoll  = this._ramp(this.smoothRoll, targetRoll, dt);
    this.smoothYaw   = this._ramp(this.smoothYaw, targetYaw, dt);

    model.pitchInput = this.smoothPitch;
    model.rollInput  = this.smoothRoll;
    model.yawInput   = this.smoothYaw;
  }

  _ramp(current, target, dt) {
    const diff = target - current;
    const step = this.rampRate * dt;
    if (Math.abs(diff) < step) return target;
    return current + Math.sign(diff) * step;
  }
}

// ============================================================
// HUD — update display elements
// ============================================================
function updateHUD(model) {
  // Extract angles directly from orientation axes (avoids Euler convention mismatch)
  const forward = model.getForward();
  const up = model.getUp();
  const right = model.getRight();
  const worldUp = new Vec3(0, 1, 0);

  // Pitch: how far nose is above/below horizon
  const pitchDeg = Math.asin(Math.max(-1, Math.min(1, forward.y))) * 180 / Math.PI;

  // Roll: bank angle (positive = right wing down / right bank)
  const rollDeg = Math.atan2(-right.dot(worldUp), up.dot(worldUp)) * 180 / Math.PI;

  // Heading: compass bearing (0=north/-Z, 90=east/+X)
  let headingDeg = Math.atan2(forward.x, -forward.z) * 180 / Math.PI;
  if (headingDeg < 0) headingDeg += 360;

  // Unit conversions: m→ft, m/s→knots, m/s→ft/min
  const M_TO_FT = 3.28084;
  const MS_TO_KT = 1.94384;
  const MS_TO_FPM = 196.85;

  document.getElementById('alt').textContent   = (model.altitude * M_TO_FT).toFixed(0) + ' ft';

  // AGL with color warnings (thresholds in meters: 50m ≈ 164ft, 150m ≈ 492ft)
  const aglEl = document.getElementById('agl');
  aglEl.textContent = (model.agl * M_TO_FT).toFixed(0) + ' ft';
  if (!model.onGround && model.agl < 50) {
    aglEl.style.color = '#f00';
  } else if (!model.onGround && model.agl < 150) {
    aglEl.style.color = '#ff0';
  } else {
    aglEl.style.color = '#0f0';
  }

  document.getElementById('spd').textContent   = (model.airspeed * MS_TO_KT).toFixed(0) + ' kt';
  document.getElementById('vs').textContent    = (model.verticalSpeed * MS_TO_FPM).toFixed(0) + ' fpm';
  document.getElementById('pitch').textContent = pitchDeg.toFixed(1) + '°';
  document.getElementById('roll').textContent  = rollDeg.toFixed(1) + '°';
  document.getElementById('hdg').textContent   = headingDeg.toFixed(0) + '°';
  document.getElementById('thr').textContent   = (model.throttle * 100).toFixed(0) + '%';
  document.getElementById('aoa').textContent   = (model.aoa * 180 / Math.PI).toFixed(1) + '°';

  // Artificial horizon — roll negated so banking right tilts horizon left (pilot perspective)
  document.getElementById('horizon-ball').style.transform =
    `rotate(${-rollDeg}deg) translateY(${pitchDeg * 1.5}px)`;

  // Throttle bar
  document.getElementById('throttle-fill').style.height = (model.throttle * 100) + '%';

  const stallEl = document.getElementById('stall');
  stallEl.className = model.isStalling ? 'stall active' : 'stall';

  // Flight state badge
  const stateEl = document.getElementById('flight-state');
  if (model.crashed) {
    stateEl.innerHTML = '<span class="state-badge" style="background:#550000;color:#ff4444;">CRASH</span>';
  } else if (model.onGround) {
    stateEl.innerHTML = '<span class="state-badge gnd">GND</span>';
  } else {
    stateEl.innerHTML = '<span class="state-badge air">AIR</span>';
  }

  // Crash overlay
  const crashOverlay = document.getElementById('crash-overlay');
  crashOverlay.className = model.crashed ? 'visible' : '';
}

// ============================================================
// Babylon.js Scene Setup
// ============================================================
function createScene(engine) {
  const scene = new BABYLON.Scene(engine);
  scene.useRightHandedSystem = true;

  // Clear color (sky blue)
  scene.clearColor = new BABYLON.Color4(0.53, 0.72, 0.88, 1);

  // Lights
  const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), scene);
  hemi.intensity = 0.6;

  const sun = new BABYLON.DirectionalLight('sun', new BABYLON.Vector3(-0.5, -1, -0.3), scene);
  sun.intensity = 0.8;

  // Terrain — direct vertex positioning from getTerrainHeight (no heightmap intermediary)
  const TERRAIN_SUBS = 250;
  const ground = BABYLON.MeshBuilder.CreateGround('terrain', {
    width: TERRAIN_SIZE,
    height: TERRAIN_SIZE,
    subdivisions: TERRAIN_SUBS,
    updatable: true
  }, scene);

  // Set vertex Y positions directly from getTerrainHeight
  const positions = ground.getVerticesData(BABYLON.VertexBuffer.PositionKind);
  for (let i = 0; i < positions.length; i += 3) {
    positions[i + 1] = getTerrainHeight(positions[i], positions[i + 2]);
  }
  ground.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions);

  // Flip normals on first render — useRightHandedSystem inverts ground normals
  let terrainNormalsFlipped = false;
  scene.onBeforeRenderObservable.add(() => {
    if (terrainNormalsFlipped) return;
    const normals = ground.getVerticesData(BABYLON.VertexBuffer.NormalKind);
    if (normals && normals[1] < 0) {
      for (let i = 0; i < normals.length; i++) normals[i] = -normals[i];
      ground.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals);
      terrainNormalsFlipped = true;
    }
  });

  // Altitude-based color texture via DynamicTexture
  const terrainMat = new BABYLON.StandardMaterial('terrainMat', scene);
  const terrainTex = new BABYLON.DynamicTexture('terrainTex', { width: 512, height: 512 }, scene);
  const tctx = terrainTex.getContext();
  const terrainImgData = tctx.createImageData(512, 512);
  for (let py = 0; py < 512; py++) {
    for (let px = 0; px < 512; px++) {
      const wx = (px / 511 - 0.5) * TERRAIN_SIZE;
      const wz = (py / 511 - 0.5) * TERRAIN_SIZE;
      const h = getTerrainHeight(wx, wz);
      const t = h / TERRAIN_MAX_HEIGHT; // 0..1
      let r, g, b;
      if (t < 0.25) {
        // Green lowland
        r = 60 + t * 200; g = 120 + t * 200; b = 40;
      } else if (t < 0.5) {
        // Brown midland
        const u = (t - 0.25) / 0.25;
        r = 110 + u * 50; g = 170 - u * 70; b = 40 + u * 20;
      } else if (t < 0.75) {
        // Gray highland
        const u = (t - 0.5) / 0.25;
        r = 130 + u * 40; g = 120 + u * 20; b = 100 + u * 30;
      } else {
        // White peaks
        const u = (t - 0.75) / 0.25;
        r = 180 + u * 75; g = 175 + u * 80; b = 165 + u * 90;
      }
      const idx = (py * 512 + px) * 4;
      terrainImgData.data[idx] = r | 0;
      terrainImgData.data[idx + 1] = g | 0;
      terrainImgData.data[idx + 2] = b | 0;
      terrainImgData.data[idx + 3] = 255;
    }
  }
  tctx.putImageData(terrainImgData, 0, 0);
  terrainTex.update();
  terrainMat.diffuseTexture = terrainTex;
  terrainMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
  ground.material = terrainMat;

  // Runway — 30m wide, 800m long, along -Z axis
  const runway = BABYLON.MeshBuilder.CreateGround('runway', { width: 30, height: 800 }, scene);
  runway.position.y = 0.01; // slightly above ground to prevent z-fighting
  runway.position.z = -400; // centered so aircraft starts at near end
  runway.renderingGroupId = 1;

  // Runway material with center dashed line via DynamicTexture
  const runwayMat = new BABYLON.StandardMaterial('runwayMat', scene);
  const runwayTex = new BABYLON.DynamicTexture('runwayTex', { width: 128, height: 2048 }, scene);
  const rctx = runwayTex.getContext();
  // Dark gray asphalt
  rctx.fillStyle = '#333338';
  rctx.fillRect(0, 0, 128, 2048);
  // White edge lines
  rctx.fillStyle = '#cccccc';
  rctx.fillRect(4, 0, 3, 2048);     // left edge
  rctx.fillRect(121, 0, 3, 2048);   // right edge
  // Center dashed line
  rctx.fillStyle = '#ffffff';
  for (let i = 0; i < 2048; i += 64) {
    rctx.fillRect(62, i, 4, 40);    // 40px dash, 24px gap
  }
  // Threshold markings at start
  rctx.fillStyle = '#ffffff';
  for (let s = 0; s < 8; s++) {
    const sx = 16 + s * 12;
    rctx.fillRect(sx, 1980, 8, 60);
  }
  runwayTex.update();
  runwayMat.diffuseTexture = runwayTex;
  runwayMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
  runway.material = runwayMat;

  // Sky sphere
  const sky = BABYLON.MeshBuilder.CreateSphere('sky', { diameter: 18000, segments: 16 }, scene);
  sky.infiniteDistance = true;
  const skyMat = new BABYLON.StandardMaterial('skyMat', scene);
  skyMat.backFaceCulling = false;
  skyMat.disableLighting = true;
  // Dynamic texture for gradient sky
  const skyTex = new BABYLON.DynamicTexture('skyTex', { width: 1, height: 256 }, scene);
  const ctx = skyTex.getContext();
  const gradient = ctx.createLinearGradient(0, 0, 0, 256);
  gradient.addColorStop(0.0, '#0a1a3f');   // dark blue top
  gradient.addColorStop(0.4, '#2266aa');   // mid blue
  gradient.addColorStop(0.7, '#88bbdd');   // pale blue
  gradient.addColorStop(1.0, '#c8dde8');   // horizon
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 1, 256);
  skyTex.update();
  skyMat.diffuseTexture = skyTex;
  skyMat.emissiveTexture = skyTex;
  sky.material = skyMat;

  // Fog — hides ground edges
  scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
  scene.fogStart = 4000;
  scene.fogEnd = 8000;
  scene.fogColor = new BABYLON.Color3(0.78, 0.87, 0.91); // match horizon

  return scene;
}

// ============================================================
// Aircraft Mesh — built from primitives
// ============================================================
function createAircraftMesh(scene) {
  const root = new BABYLON.TransformNode('aircraft', scene);

  // Offset body up so fuselage bottom sits at ground level (radius 0.6 + 0.1 gear clearance)
  const body = new BABYLON.TransformNode('body', scene);
  body.parent = root;
  body.position.y = 0.7;

  // Materials
  const grayMat = new BABYLON.StandardMaterial('gray', scene);
  grayMat.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.65);

  const darkGrayMat = new BABYLON.StandardMaterial('darkGray', scene);
  darkGrayMat.diffuseColor = new BABYLON.Color3(0.35, 0.35, 0.4);

  const lightGrayMat = new BABYLON.StandardMaterial('lightGray', scene);
  lightGrayMat.diffuseColor = new BABYLON.Color3(0.75, 0.75, 0.78);

  // Fuselage — cylinder along Y, rotate 90° around X so it lies along Z
  const fuselage = BABYLON.MeshBuilder.CreateCylinder('fuselage', {
    diameter: 1.2, height: 8, tessellation: 12
  }, scene);
  fuselage.rotation.x = Math.PI / 2;
  fuselage.material = grayMat;
  fuselage.parent = body;

  // Nose cone — tapered cylinder
  const nose = BABYLON.MeshBuilder.CreateCylinder('nose', {
    diameterTop: 0.3, diameterBottom: 1.2, height: 1.5, tessellation: 12
  }, scene);
  nose.rotation.x = Math.PI / 2;
  nose.position.z = -4.75;
  nose.material = darkGrayMat;
  nose.parent = body;

  // Wings — box
  const wings = BABYLON.MeshBuilder.CreateBox('wings', {
    width: 12, height: 0.15, depth: 1.8
  }, scene);
  wings.position.y = -0.1;
  wings.position.z = -0.5;
  wings.material = lightGrayMat;
  wings.parent = body;

  // Horizontal stabilizer
  const hStab = BABYLON.MeshBuilder.CreateBox('hStab', {
    width: 4, height: 0.1, depth: 0.8
  }, scene);
  hStab.position.y = 0.2;
  hStab.position.z = 3.8;
  hStab.material = lightGrayMat;
  hStab.parent = body;

  // Vertical stabilizer
  const vStab = BABYLON.MeshBuilder.CreateBox('vStab', {
    width: 0.1, height: 1.8, depth: 1.2
  }, scene);
  vStab.position.y = 1.0;
  vStab.position.z = 3.5;
  vStab.material = lightGrayMat;
  vStab.parent = body;

  // Render aircraft on top of terrain (same group as runway)
  root.getChildMeshes().forEach(m => m.renderingGroupId = 1);

  root.rotationQuaternion = new BABYLON.Quaternion(0, 0, 0, 1);
  return root;
}

// ============================================================
// Chase Camera
// ============================================================
class ChaseCamera {
  constructor(scene) {
    this.camera = new BABYLON.FreeCamera('chase', BABYLON.Vector3.Zero(), scene);
    this.camera.inputs.clear(); // prevent Babylon's default WASD/arrow controls
    this.camera.minZ = 0.5;
    this.camera.maxZ = 10000;
    this.camera.fov = 1.0;

    // Offset in aircraft local space: 5m above, 20m behind (+Z = behind)
    this.offset = new BABYLON.Vector3(0, 5, 20);

    this.smoothedPosition = null;
    this.smoothedTarget = null;
    this.alpha = 0.08;
    this.baseDt = 1 / 60;
  }

  update(aircraftMesh, dt) {
    const meshQ = aircraftMesh.rotationQuaternion;
    const meshPos = aircraftMesh.position;

    // Rotate offset by aircraft orientation to get desired world position
    const offsetWorld = new BABYLON.Vector3(0, 0, 0);
    const rotMatrix = new BABYLON.Matrix();
    BABYLON.Matrix.FromQuaternionToRef(meshQ, rotMatrix);
    BABYLON.Vector3.TransformCoordinatesToRef(this.offset, rotMatrix, offsetWorld);

    const desiredPos = meshPos.add(offsetWorld);
    const desiredTarget = meshPos.clone();

    // Initialize on first frame
    if (!this.smoothedPosition) {
      this.smoothedPosition = desiredPos.clone();
      this.smoothedTarget = desiredTarget.clone();
    }

    // Frame-rate adjusted lerp alpha
    const a = 1 - Math.pow(1 - this.alpha, dt / this.baseDt);

    BABYLON.Vector3.LerpToRef(this.smoothedPosition, desiredPos, a, this.smoothedPosition);
    BABYLON.Vector3.LerpToRef(this.smoothedTarget, desiredTarget, a, this.smoothedTarget);

    // Clamp camera above terrain (never underground)
    const terrainH = getTerrainHeight(this.smoothedPosition.x, this.smoothedPosition.z);
    if (this.smoothedPosition.y < terrainH + 2) this.smoothedPosition.y = terrainH + 2;

    this.camera.position.copyFrom(this.smoothedPosition);
    this.camera.setTarget(this.smoothedTarget);
  }
}

// ============================================================
// Game Loop — Babylon engine render loop with fixed timestep physics
// ============================================================
const FIXED_DT = 1 / 60;
const MAX_FRAME_DT = 0.1;

const model = new FlightModel();
model.getGroundHeight = getTerrainHeight;
const input = new InputHandler();

const canvas = document.getElementById('renderCanvas');
const engine = new BABYLON.Engine(canvas, true, { stencil: true });
const scene = createScene(engine);
const aircraftMesh = createAircraftMesh(scene);
const chaseCamera = new ChaseCamera(scene);
scene.activeCamera = chaseCamera.camera;

let lastTime = null;
let accumulator = 0;

// Previous state for interpolation (eliminates fixed-timestep stutter)
let prevPosition = new Vec3(model.position.x, model.position.y, model.position.z);
let prevOrientation = model.orientation.clone();

// Restart function
function restart() {
  model.reset();
  model.position.y = getTerrainHeight(0, 0);
  accumulator = 0;
  lastTime = null;
  prevPosition.set(0, model.position.y, 0);
  prevOrientation = new Quat(0, 0, 0, 1);
  // Reset camera smoothing
  chaseCamera.smoothedPosition = null;
  chaseCamera.smoothedTarget = null;
}

let paused = false;

// Listen for R key to restart after crash, P/Escape to toggle pause
window.addEventListener('keydown', (e) => {
  if (e.code === 'KeyR' && model.crashed) {
    restart();
    paused = false;
  }
  if (e.code === 'KeyP' || e.code === 'Escape') {
    if (!model.crashed) {
      paused = !paused;
      if (!paused) lastTime = null; // reset dt so no huge jump after unpause
    }
  }
});

engine.runRenderLoop(() => {
  // Pause overlay
  document.getElementById('pause-overlay').className = paused ? 'visible' : '';

  const now = performance.now();
  if (lastTime === null) { lastTime = now; return; }

  let frameDt = (now - lastTime) / 1000;
  lastTime = now;

  if (frameDt > MAX_FRAME_DT) frameDt = MAX_FRAME_DT;

  // When paused, still render but skip physics and input
  if (paused) { scene.render(); return; }

  // 1. Input — skip when crashed
  if (!model.crashed) {
    input.update(frameDt, model);
  }

  // 2. Fixed timestep physics with state snapshots for interpolation
  accumulator += frameDt;
  while (accumulator >= FIXED_DT) {
    prevPosition.set(model.position.x, model.position.y, model.position.z);
    prevOrientation = model.orientation.clone();
    model.stepPhysics(FIXED_DT);
    accumulator -= FIXED_DT;
  }

  // 3. Interpolate visual mesh between previous and current physics state
  const alpha = accumulator / FIXED_DT;
  aircraftMesh.position.set(
    prevPosition.x + (model.position.x - prevPosition.x) * alpha,
    prevPosition.y + (model.position.y - prevPosition.y) * alpha,
    prevPosition.z + (model.position.z - prevPosition.z) * alpha
  );
  // Slerp orientation
  const po = prevOrientation, co = model.orientation;
  let dot = po.x * co.x + po.y * co.y + po.z * co.z + po.w * co.w;
  const sign = dot < 0 ? -1 : 1;
  dot *= sign;
  // For very small angles, use lerp to avoid division by zero
  let s0, s1;
  if (dot > 0.9995) {
    s0 = 1 - alpha;
    s1 = alpha * sign;
  } else {
    const omega = Math.acos(dot);
    const sinOmega = Math.sin(omega);
    s0 = Math.sin((1 - alpha) * omega) / sinOmega;
    s1 = Math.sin(alpha * omega) / sinOmega * sign;
  }
  aircraftMesh.rotationQuaternion.set(
    s0 * po.x + s1 * co.x,
    s0 * po.y + s1 * co.y,
    s0 * po.z + s1 * co.z,
    s0 * po.w + s1 * co.w
  );

  // 4. Chase camera
  chaseCamera.update(aircraftMesh, frameDt);

  // 5. HUD (unchanged)
  updateHUD(model);

  // 6. Render
  scene.render();
});

window.addEventListener('resize', () => engine.resize());
</script>
</body>
</html>
