<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flight Sim — Phase 9</title>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    color: #0f0;
    font-family: 'Courier New', monospace;
    overflow: hidden;
    height: 100vh;
  }
  #renderCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
    outline: none;
  }
  #hud {
    display: none;
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 10;
    pointer-events: none;
    background: rgba(0, 0, 0, 0.85);
    border: 1px solid #0f0;
    padding: 24px 32px;
    border-radius: 8px;
    font-size: 16px;
    line-height: 1.8;
    min-width: 340px;
  }
  #hud.visible { display: block; }

  /* ===== Flight HUD Overlay ===== */
  #flight-hud {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 10;
    pointer-events: none;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    color: #00ff00;
    text-shadow: 0 0 4px rgba(0,0,0,0.9), 0 0 8px rgba(0,0,0,0.5);
  }

  /* Heading Tape */
  #heading-tape {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 40vw;
    height: 32px;
    overflow: hidden;
    background: rgba(0,0,0,0.35);
    -webkit-mask-image: linear-gradient(to right, transparent 0%, black 15%, black 85%, transparent 100%);
    mask-image: linear-gradient(to right, transparent 0%, black 15%, black 85%, transparent 100%);
  }
  #heading-tape-strip {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
  }
  .hdg-tick {
    position: absolute;
    top: 0;
    width: 1px;
    height: 10px;
    background: #00ff00;
    will-change: transform;
  }
  .hdg-tick.major { height: 16px; }
  .hdg-label {
    position: absolute;
    top: 14px;
    font-size: 11px;
    color: #00ff00;
    transform: translateX(-50%);
    white-space: nowrap;
    will-change: transform;
  }
  #heading-caret {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 0; height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 8px solid #00ff00;
    z-index: 2;
  }
  #heading-readout {
    position: absolute;
    top: 56px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 16px;
    font-weight: bold;
    color: #00ff00;
    text-align: center;
  }

  /* Pitch Ladder */
  #pitch-clip {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 40vw;
    height: 50vh;
    overflow: hidden;
  }
  #pitch-ladder {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    will-change: transform;
  }
  .pitch-line {
    position: absolute;
    left: 50%;
    height: 1px;
    background: #00ff00;
    filter: drop-shadow(0 0 3px rgba(0,0,0,0.9));
  }
  .pitch-line.horizon {
    width: 300px;
    margin-left: -150px;
    height: 2px;
  }
  .pitch-line.above {
    border-top: 1px solid #00ff00;
    background: none;
  }
  .pitch-line.below {
    border-top: 1px dashed #00ff00;
    background: none;
  }
  .pitch-deg-label {
    position: absolute;
    font-size: 10px;
    color: #00ff00;
    top: -6px;
  }
  .pitch-deg-label.left { right: 100%; margin-right: 4px; }
  .pitch-deg-label.right { left: 100%; margin-left: 4px; }

  /* Aircraft Symbol (fixed center) */
  #aircraft-symbol {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 60px;
    height: 2px;
    pointer-events: none;
    z-index: 3;
    filter: drop-shadow(0 0 3px rgba(0,0,0,0.9));
  }
  #aircraft-symbol::before,
  #aircraft-symbol::after {
    content: '';
    position: absolute;
    top: 0;
    height: 2px;
    width: 20px;
    background: #00ff00;
  }
  #aircraft-symbol::before { left: 0; }
  #aircraft-symbol::after { right: 0; }
  #aircraft-dot {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 4px;
    height: 4px;
    margin: -2px 0 0 -2px;
    background: #00ff00;
    border-radius: 50%;
    z-index: 3;
  }

  /* Speed Tape (left) */
  #speed-tape {
    position: absolute;
    left: 30px;
    top: 50%;
    transform: translateY(-50%);
    width: 70px;
    height: 300px;
    overflow: hidden;
    background: rgba(0,0,0,0.35);
    -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
    mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
  }
  #speed-tape-strip {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
  }
  .spd-tick {
    position: absolute;
    right: 0;
    width: 8px;
    height: 1px;
    background: #00ff00;
    will-change: transform;
  }
  .spd-tick.major { width: 14px; }
  .spd-label {
    position: absolute;
    right: 16px;
    font-size: 11px;
    color: #00ff00;
    transform: translateY(-50%);
    white-space: nowrap;
    will-change: transform;
  }
  #speed-caret {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 0; height: 0;
    border-top: 6px solid transparent;
    border-bottom: 6px solid transparent;
    border-right: 8px solid #00ff00;
    z-index: 2;
  }
  #speed-readout {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 16px;
    font-weight: bold;
    color: #00ff00;
    background: rgba(0,0,0,0.5);
    padding: 2px 6px;
    z-index: 3;
  }

  /* Altitude Tape (right) */
  #alt-tape {
    position: absolute;
    right: 30px;
    top: 50%;
    transform: translateY(-50%);
    width: 70px;
    height: 300px;
    overflow: hidden;
    background: rgba(0,0,0,0.35);
    -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
    mask-image: linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%);
  }
  #alt-tape-strip {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
  }
  .alt-tick {
    position: absolute;
    left: 0;
    width: 8px;
    height: 1px;
    background: #00ff00;
    will-change: transform;
  }
  .alt-tick.major { width: 14px; }
  .alt-label {
    position: absolute;
    left: 16px;
    font-size: 11px;
    color: #00ff00;
    transform: translateY(-50%);
    white-space: nowrap;
    will-change: transform;
  }
  #alt-caret {
    position: absolute;
    top: 50%;
    left: 0;
    transform: translateY(-50%);
    width: 0; height: 0;
    border-top: 6px solid transparent;
    border-bottom: 6px solid transparent;
    border-left: 8px solid #00ff00;
    z-index: 2;
  }
  #alt-readout {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 16px;
    font-weight: bold;
    color: #00ff00;
    background: rgba(0,0,0,0.5);
    padding: 2px 6px;
    z-index: 3;
  }

  /* AGL Readout */
  #agl-readout {
    position: absolute;
    right: 30px;
    top: calc(50% + 165px);
    width: 70px;
    text-align: center;
    font-size: 12px;
    color: #00ff00;
  }
  #agl-readout .agl-label { color: #0a0; font-size: 10px; }

  /* Throttle Indicator */
  #hud-throttle {
    position: absolute;
    left: 30px;
    top: calc(50% + 170px);
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #hud-throttle-track {
    width: 8px;
    height: 80px;
    background: rgba(0,0,0,0.35);
    position: relative;
    overflow: hidden;
  }
  #hud-throttle-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background: linear-gradient(to top, #00ff00, #ffaa00);
  }
  #hud-throttle-label {
    font-size: 10px;
    color: #0a0;
    margin-top: 2px;
  }

  /* Vertical Speed Readout */
  #vs-readout {
    position: absolute;
    right: 30px;
    top: calc(50% + 185px);
    width: 70px;
    text-align: center;
    font-size: 12px;
    color: #00ff00;
  }

  /* Flight Path Marker */
  #fpm {
    position: absolute;
    width: 16px;
    height: 16px;
    border: 1.5px solid #00ff00;
    border-radius: 50%;
    will-change: transform;
    display: none;
    z-index: 4;
    filter: drop-shadow(0 0 3px rgba(0,0,0,0.9));
  }
  #fpm::before {
    content: '';
    position: absolute;
    top: -8px;
    left: 50%;
    width: 1.5px;
    height: 8px;
    background: #00ff00;
    transform: translateX(-50%);
  }
  #fpm::after {
    content: '';
    position: absolute;
    top: 50%;
    left: -10px;
    width: 10px;
    height: 1.5px;
    background: #00ff00;
    transform: translateY(-50%);
  }
  #fpm-right-wing {
    position: absolute;
    top: 50%;
    right: -10px;
    width: 10px;
    height: 1.5px;
    background: #00ff00;
    transform: translateY(-50%);
  }

  /* Stall Warning */
  #hud-stall {
    position: absolute;
    top: calc(50% - 120px);
    left: 50%;
    transform: translateX(-50%);
    font-size: 24px;
    font-weight: bold;
    color: #ff0000;
    display: none;
    z-index: 5;
    animation: blink 0.3s infinite;
  }

  #boundary-warning {
    position: absolute;
    top: calc(50% + 80px);
    left: 50%;
    transform: translateX(-50%);
    font-size: 22px;
    font-weight: bold;
    color: #ff3300;
    display: none;
    z-index: 5;
    animation: blink 0.5s infinite;
    letter-spacing: 2px;
  }
  #boundary-warning.visible { display: block; }

  /* State Indicator */
  #hud-state {
    position: absolute;
    top: 20px;
    left: 20px;
    font-size: 14px;
    font-weight: bold;
    letter-spacing: 1px;
  }
  #hud h2 {
    text-align: center;
    margin-bottom: 12px;
    font-size: 18px;
    border-bottom: 1px solid #0a0;
    padding-bottom: 8px;
  }
  .row { display: flex; justify-content: space-between; }
  .label { color: #0a0; }
  .value { color: #0f0; font-weight: bold; }
  .stall {
    text-align: center;
    margin-top: 12px;
    font-size: 20px;
    font-weight: bold;
    color: #f00;
    visibility: hidden;
  }
  .stall.active { visibility: visible; animation: blink 0.3s infinite; }
  @keyframes blink { 50% { opacity: 0; } }

  /* Artificial Horizon */
  #horizon-container {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    overflow: hidden;
    border: 2px solid #0f0;
    margin: 12px auto;
    position: relative;
    background: #111;
  }
  #horizon-ball {
    width: 100%;
    height: 300px;
    position: absolute;
    top: 50%;
    left: 0;
    margin-top: -150px;
    transform-origin: center 150px;
  }
  #horizon-sky {
    width: 100%;
    height: 150px;
    background: linear-gradient(to bottom, #1a3a6a, #3a7abf);
  }
  #horizon-ground {
    width: 100%;
    height: 150px;
    background: linear-gradient(to bottom, #7a5c2e, #4a3518);
  }
  #horizon-line {
    position: absolute;
    top: 150px;
    left: 0;
    width: 100%;
    height: 1px;
    background: #fff;
  }
  .pitch-mark {
    position: absolute;
    left: 50%;
    height: 1px;
    background: rgba(255, 255, 255, 0.6);
  }
  .pitch-mark.deg10 { width: 30px; margin-left: -15px; }
  .pitch-mark.deg20 { width: 50px; margin-left: -25px; }
  .pitch-mark.up10 { top: 135px; }
  .pitch-mark.up20 { top: 120px; }
  .pitch-mark.dn10 { top: 165px; }
  .pitch-mark.dn20 { top: 180px; }
  #horizon-wings {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
  }
  #horizon-wings::before,
  #horizon-wings::after {
    content: '';
    position: absolute;
    top: -1px;
    height: 3px;
    width: 25px;
    background: #f80;
  }
  #horizon-wings::before { right: 8px; }
  #horizon-wings::after { left: 8px; }
  #horizon-dot {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 6px;
    height: 6px;
    margin: -3px 0 0 -3px;
    background: #f80;
    border-radius: 50%;
    z-index: 2;
  }

  /* Throttle Bar */
  #hud-instruments {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    margin: 8px 0;
  }
  #throttle-bar {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }
  #throttle-track {
    width: 20px;
    height: 120px;
    border: 1px solid #0f0;
    position: relative;
    border-radius: 3px;
    overflow: hidden;
  }
  #throttle-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background: linear-gradient(to top, #0a0, #0f0);
    transition: height 0.05s linear;
  }
  #throttle-label {
    font-size: 10px;
    color: #0a0;
    letter-spacing: 1px;
  }
  /* Crash overlay */
  #crash-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 20;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Courier New', monospace;
  }
  #crash-overlay.visible { display: flex; }
  #crash-overlay .crash-title {
    font-size: 64px;
    font-weight: bold;
    color: #f00;
    text-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
    margin-bottom: 20px;
  }
  #crash-overlay .crash-subtitle {
    font-size: 20px;
    color: #ccc;
  }

  /* Pause overlay */
  #pause-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 20;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Courier New', monospace;
  }
  #pause-overlay.visible { display: flex; }
  #pause-overlay .pause-title {
    font-size: 48px;
    font-weight: bold;
    color: #fff;
    margin-bottom: 16px;
  }
  #pause-overlay .pause-subtitle {
    font-size: 18px;
    color: #aaa;
  }

  /* Ground state indicator */
  .state-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 3px;
    font-size: 12px;
    font-weight: bold;
    letter-spacing: 1px;
  }
  .state-badge.gnd { background: #553300; color: #ffaa00; }
  .state-badge.air { background: #003355; color: #00aaff; }

  /* Gear Indicator */
  #hud-gear {
    position: absolute;
    bottom: 80px;
    right: 40px;
    font-size: 16px;
    font-weight: bold;
    letter-spacing: 1px;
    color: #00ff00;
  }
  /* Auto-Level Indicator */
  #hud-autolevel {
    position: absolute;
    bottom: 56px;
    right: 40px;
    font-size: 13px;
    color: #00ccff;
    letter-spacing: 1px;
  }

  #controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: #0a0;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    text-align: center;
    opacity: 0.7;
  }
</style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<!-- Flight HUD Overlay -->
<div id="flight-hud">
  <!-- State Indicator -->
  <div id="hud-state"></div>

  <!-- Heading Tape -->
  <div id="heading-tape">
    <div id="heading-tape-strip"></div>
    <div id="heading-caret"></div>
  </div>
  <div id="heading-readout">000</div>

  <!-- Pitch Ladder -->
  <div id="pitch-clip">
    <div id="pitch-ladder"></div>
  </div>
  <div id="aircraft-symbol"></div>
  <div id="aircraft-dot"></div>

  <!-- Speed Tape -->
  <div id="speed-tape">
    <div id="speed-tape-strip"></div>
    <div id="speed-caret"></div>
    <div id="speed-readout">0</div>
  </div>

  <!-- Altitude Tape -->
  <div id="alt-tape">
    <div id="alt-tape-strip"></div>
    <div id="alt-caret"></div>
    <div id="alt-readout">0</div>
  </div>

  <!-- AGL Readout -->
  <div id="agl-readout">
    <div class="agl-label">AGL</div>
    <div id="agl-value">0</div>
  </div>

  <!-- Throttle -->
  <div id="hud-throttle">
    <div id="hud-throttle-track">
      <div id="hud-throttle-fill"></div>
    </div>
    <div id="hud-throttle-label">THR</div>
  </div>

  <!-- Vertical Speed -->
  <div id="vs-readout">0</div>

  <!-- Flight Path Marker -->
  <div id="fpm"><div id="fpm-right-wing"></div></div>

  <!-- Stall Warning -->
  <div id="hud-stall">STALL</div>

  <!-- Gear Indicator -->
  <div id="hud-gear">GEAR DN</div>

  <!-- Auto-Level Indicator -->
  <div id="hud-autolevel">AUTOLVL</div>

  <!-- Boundary Warning -->
  <div id="boundary-warning">LEAVING AREA</div>
</div>

<div id="hud">
  <h2>FLIGHT DATA</h2>
  <div class="row"><span class="label">MSL Alt</span><span class="value" id="alt">0 ft</span></div>
  <div class="row"><span class="label">AGL</span><span class="value" id="agl">0 ft</span></div>
  <div class="row"><span class="label">Airspeed</span><span class="value" id="spd">0 kt</span></div>
  <div class="row"><span class="label">Vert Speed</span><span class="value" id="vs">0 fpm</span></div>
  <div class="row"><span class="label">Pitch</span><span class="value" id="pitch">0°</span></div>
  <div class="row"><span class="label">Roll</span><span class="value" id="roll">0°</span></div>
  <div class="row"><span class="label">Heading</span><span class="value" id="hdg">0°</span></div>
  <div class="row"><span class="label">State</span><span class="value" id="flight-state"><span class="state-badge gnd">GND</span></span></div>

  <div id="hud-instruments">
    <div id="horizon-container">
      <div id="horizon-ball">
        <div id="horizon-sky"></div>
        <div id="horizon-ground"></div>
        <div id="horizon-line"></div>
        <div class="pitch-mark deg10 up10"></div>
        <div class="pitch-mark deg20 up20"></div>
        <div class="pitch-mark deg10 dn10"></div>
        <div class="pitch-mark deg20 dn20"></div>
      </div>
      <div id="horizon-wings"></div>
      <div id="horizon-dot"></div>
    </div>
    <div id="throttle-bar">
      <div id="throttle-track">
        <div id="throttle-fill"></div>
      </div>
      <div id="throttle-label">THR</div>
    </div>
  </div>

  <div class="row"><span class="label">Throttle</span><span class="value" id="thr">0%</span></div>
  <div class="row"><span class="label">AoA</span><span class="value" id="aoa">0°</span></div>
  <div class="stall" id="stall">!! STALL !!</div>
</div>

<div id="controls">
  ↑↓ Pitch &nbsp;|&nbsp; ←→ Roll &nbsp;|&nbsp; A/D Yaw &nbsp;|&nbsp; W/S Throttle &nbsp;|&nbsp; G Gear &nbsp;|&nbsp; L AutoLvl &nbsp;|&nbsp; P Pause &nbsp;|&nbsp; ` Debug
</div>

<div id="crash-overlay">
  <div class="crash-title">CRASHED</div>
  <div class="crash-subtitle">Press R to restart</div>
</div>

<div id="pause-overlay">
  <div class="pause-title">PAUSED</div>
  <div class="pause-subtitle">Press P to resume</div>
</div>

<script>
// ============================================================
// Vector3 — minimal 3D vector math
// ============================================================
class Vec3 {
  constructor(x = 0, y = 0, z = 0) { this.x = x; this.y = y; this.z = z; }
  set(x, y, z) { this.x = x; this.y = y; this.z = z; return this; }
  copy(v) { this.x = v.x; this.y = v.y; this.z = v.z; return this; }
  clone() { return new Vec3(this.x, this.y, this.z); }
  add(v) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
  sub(v) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
  scale(s) { return new Vec3(this.x * s, this.y * s, this.z * s); }
  addScaled(v, s) { return new Vec3(this.x + v.x * s, this.y + v.y * s, this.z + v.z * s); }
  dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
  cross(v) {
    return new Vec3(
      this.y * v.z - this.z * v.y,
      this.z * v.x - this.x * v.z,
      this.x * v.y - this.y * v.x
    );
  }
  length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }
  lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z; }
  normalize() {
    const len = this.length();
    if (len < 1e-10) return new Vec3(0, 0, 0);
    return this.scale(1 / len);
  }
}

// ============================================================
// Quaternion — orientation math
// ============================================================
class Quat {
  constructor(x = 0, y = 0, z = 0, w = 1) { this.x = x; this.y = y; this.z = z; this.w = w; }
  clone() { return new Quat(this.x, this.y, this.z, this.w); }

  multiply(q) {
    return new Quat(
      this.w * q.x + this.x * q.w + this.y * q.z - this.z * q.y,
      this.w * q.y - this.x * q.z + this.y * q.w + this.z * q.x,
      this.w * q.z + this.x * q.y - this.y * q.x + this.z * q.w,
      this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z
    );
  }

  normalize() {
    const len = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    if (len < 1e-10) return new Quat(0, 0, 0, 1);
    return new Quat(this.x / len, this.y / len, this.z / len, this.w / len);
  }

  // Rotate a vector by this quaternion: q * v * q^-1
  rotateVec(v) {
    const qv = new Quat(v.x, v.y, v.z, 0);
    const qConj = new Quat(-this.x, -this.y, -this.z, this.w);
    const result = this.multiply(qv).multiply(qConj);
    return new Vec3(result.x, result.y, result.z);
  }

  // Create quaternion from axis-angle
  static fromAxisAngle(axis, angle) {
    const half = angle * 0.5;
    const s = Math.sin(half);
    return new Quat(axis.x * s, axis.y * s, axis.z * s, Math.cos(half));
  }

  // Extract euler angles (pitch, yaw, roll) for display only
  toEuler() {
    const sinr = 2 * (this.w * this.x + this.y * this.z);
    const cosr = 1 - 2 * (this.x * this.x + this.y * this.y);
    const roll = Math.atan2(sinr, cosr);

    const sinp = 2 * (this.w * this.y - this.z * this.x);
    const pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * Math.PI / 2 : Math.asin(sinp);

    const siny = 2 * (this.w * this.z + this.x * this.y);
    const cosy = 1 - 2 * (this.y * this.y + this.z * this.z);
    const yaw = Math.atan2(siny, cosy);

    return { pitch, roll, yaw };
  }
}

// ============================================================
// SimplexNoise — 2D simplex noise (Stefan Gustavson algorithm)
// ============================================================
class SimplexNoise {
  constructor(seed = 0) {
    this.grad3 = [
      [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
      [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
      [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
    ];
    const p = new Uint8Array(256);
    // Simple seeded PRNG
    let s = seed;
    for (let i = 0; i < 256; i++) {
      s = (s * 16807 + 0) % 2147483647;
      p[i] = s & 255;
    }
    this.perm = new Uint8Array(512);
    this.permMod12 = new Uint8Array(512);
    for (let i = 0; i < 512; i++) {
      this.perm[i] = p[i & 255];
      this.permMod12[i] = this.perm[i] % 12;
    }
  }

  noise2D(x, y) {
    const F2 = 0.5 * (Math.sqrt(3) - 1);
    const G2 = (3 - Math.sqrt(3)) / 6;
    const s = (x + y) * F2;
    const i = Math.floor(x + s);
    const j = Math.floor(y + s);
    const t = (i + j) * G2;
    const X0 = i - t, Y0 = j - t;
    const x0 = x - X0, y0 = y - Y0;
    let i1, j1;
    if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
    const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
    const x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
    const ii = i & 255, jj = j & 255;
    const gi0 = this.permMod12[ii + this.perm[jj]];
    const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];
    const gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];
    let n0 = 0, n1 = 0, n2 = 0;
    let t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 >= 0) { t0 *= t0; n0 = t0 * t0 * (this.grad3[gi0][0] * x0 + this.grad3[gi0][1] * y0); }
    let t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 >= 0) { t1 *= t1; n1 = t1 * t1 * (this.grad3[gi1][0] * x1 + this.grad3[gi1][1] * y1); }
    let t2 = 0.5 - x2 * x2 - y2 * y2;
    if (t2 >= 0) { t2 *= t2; n2 = t2 * t2 * (this.grad3[gi2][0] * x2 + this.grad3[gi2][1] * y2); }
    return 70 * (n0 + n1 + n2); // returns [-1, 1]
  }
}

// ============================================================
// Terrain Height Function — source of truth for physics & visuals
// ============================================================
const simplex = new SimplexNoise(42);
const TERRAIN_SIZE = 10000;
const TERRAIN_MAX_HEIGHT = 600;

function getTerrainHeight(x, z) {
  // Flat zone for runway: |x| < 40 AND z in [-850, 50]
  if (Math.abs(x) < 40 && z > -850 && z < 50) return 0;

  // Wide flat airfield zone (600m) with gentle transition out to 1500m
  const dist = Math.sqrt(x * x + z * z);
  if (dist < 600) return 0;
  let flattenFactor = 1.0;
  if (dist < 1500) {
    const t = (dist - 600) / 900;
    flattenFactor = t * t * (3 - 2 * t); // smoothstep
  }

  // 4-octave fBm simplex noise
  const scale = 1 / 1200; // base frequency
  let amplitude = 1.0;
  let frequency = 1.0;
  let total = 0;
  let maxAmp = 0;
  for (let o = 0; o < 4; o++) {
    total += amplitude * simplex.noise2D(x * scale * frequency, z * scale * frequency);
    maxAmp += amplitude;
    amplitude *= 0.5;
    frequency *= 2.0;
  }

  // Normalize to [0, 1] then scale
  const normalized = (total / maxAmp + 1) * 0.5; // [-1,1] -> [0,1]
  const height = normalized * TERRAIN_MAX_HEIGHT * flattenFactor;
  return Math.max(0, height);
}

// ============================================================
// Bounded Terrain Height — ocean boundary blend at world edge
// ============================================================
const WORLD_RADIUS = 25000;
const OCEAN_BLEND_START = 22000;

function getTerrainHeightBounded(x, z) {
  const dist = Math.sqrt(x * x + z * z);
  if (dist > WORLD_RADIUS) return 0;
  const h = getTerrainHeight(x, z);
  if (dist > OCEAN_BLEND_START) {
    const t = (dist - OCEAN_BLEND_START) / (WORLD_RADIUS - OCEAN_BLEND_START);
    return h * (1 - t * t * (3 - 2 * t)); // smoothstep blend to 0
  }
  return h;
}

// ============================================================
// Terrain Texture Generator — per-chunk slope+elevation coloring
// ============================================================
function generateTerrainTexture(scene, worldX, worldZ, chunkSize, texSize) {
  const tex = new BABYLON.DynamicTexture('chunkTex', { width: texSize, height: texSize }, scene, false);
  const ctx = tex.getContext();
  const imgData = ctx.createImageData(texSize, texSize);
  const sampleD = chunkSize / texSize * 0.5;
  for (let py = 0; py < texSize; py++) {
    for (let px = 0; px < texSize; px++) {
      const wx = worldX + (px / (texSize - 1)) * chunkSize;
      const wz = worldZ + (py / (texSize - 1)) * chunkSize;
      const h = getTerrainHeightBounded(wx, wz);
      const t = h / TERRAIN_MAX_HEIGHT;

      const hpx = getTerrainHeightBounded(wx + sampleD, wz);
      const hmx = getTerrainHeightBounded(wx - sampleD, wz);
      const hpz = getTerrainHeightBounded(wx, wz + sampleD);
      const hmz = getTerrainHeightBounded(wx, wz - sampleD);
      const ddx = (hpx - hmx) / (2 * sampleD);
      const ddz = (hpz - hmz) / (2 * sampleD);
      const slopeAngle = Math.atan(Math.sqrt(ddx * ddx + ddz * ddz)) * 180 / Math.PI;

      const noiseVal = simplex.noise2D(wx * 0.01, wz * 0.01) * 0.5 + 0.5;
      const fineNoise = simplex.noise2D(wx * 0.05, wz * 0.05) * 15;

      const grassR = 65 + noiseVal * 30 + fineNoise;
      const grassG = 110 + noiseVal * 40 + fineNoise;
      const grassB = 35 + noiseVal * 15;
      const rockR = 120 + noiseVal * 35 + fineNoise;
      const rockG = 105 + noiseVal * 25 + fineNoise;
      const rockB = 85 + noiseVal * 20;
      const snowR = 230 + noiseVal * 25;
      const snowG = 235 + noiseVal * 20;
      const snowB = 240 + noiseVal * 15;

      const slopeFactor = Math.max(0, Math.min(1, (slopeAngle - 25) / 10));
      const elevRockFactor = Math.max(0, Math.min(1, (t - 0.4) / 0.2));
      const rockBlend = Math.max(slopeFactor, elevRockFactor * 0.6);

      const snowElevFactor = Math.max(0, Math.min(1, (h - 400) / 100));
      const snowSlopePenalty = Math.max(0, Math.min(1, (slopeAngle - 20) / 15));
      const snowBlend = snowElevFactor * (1 - snowSlopePenalty);

      let r = grassR + (rockR - grassR) * rockBlend;
      let g = grassG + (rockG - grassG) * rockBlend;
      let b = grassB + (rockB - grassB) * rockBlend;
      r = r + (snowR - r) * snowBlend;
      g = g + (snowG - g) * snowBlend;
      b = b + (snowB - b) * snowBlend;

      const idx = (py * texSize + px) * 4;
      imgData.data[idx] = Math.max(0, Math.min(255, r | 0));
      imgData.data[idx + 1] = Math.max(0, Math.min(255, g | 0));
      imgData.data[idx + 2] = Math.max(0, Math.min(255, b | 0));
      imgData.data[idx + 3] = 255;
    }
  }
  ctx.putImageData(imgData, 0, 0);
  tex.update();
  return tex;
}

// ============================================================
// Aircraft Profiles — flight parameters for different aircraft types
// ============================================================
const aircraftProfiles = {
  trainer: {
    name: "Training Aircraft",
    mass: 1000, wingArea: 16, maxThrust: 15000,
    clSlope: 5.5, stallAngle: 15,
    pitchAuthority: 0.6, rollAuthority: 2.0, yawAuthority: 0.4,
    pitchDamping: 3.0, rollDamping: 3.0, yawDamping: 2.5,
    pitchStability: 0.5, dihedralStrength: 1.5, weathervaneStrength: 1.5,
    trimAoA: 2, autoLevel: true, autoLevelStrength: 1.0,
    gearDragPenalty: 0.3,
  },
  fighter: {
    name: "Fighter Aircraft",
    mass: 900, wingArea: 14, maxThrust: 20000,
    clSlope: 5.0, stallAngle: 18,
    pitchAuthority: 1.0, rollAuthority: 3.5, yawAuthority: 0.6,
    pitchDamping: 2.0, rollDamping: 2.0, yawDamping: 1.8,
    pitchStability: 0.3, dihedralStrength: 0.8, weathervaneStrength: 1.0,
    trimAoA: 1, autoLevel: false, autoLevelStrength: 0.5,
    gearDragPenalty: 0.25,
  },
};
let activeProfile = aircraftProfiles.trainer;

// ============================================================
// FlightModel — core physics
// ============================================================
class FlightModel {
  constructor() {
    // --- Aircraft constants (from active profile) ---
    this.mass = activeProfile.mass;
    this.maxThrust = activeProfile.maxThrust;
    this.wingArea = activeProfile.wingArea;
    this.airDensity = 1.225;      // kg/m³ — sea level ISA

    // Lift
    this.clSlope = activeProfile.clSlope;
    this.stallAngle = activeProfile.stallAngle * Math.PI / 180;
    this.postStallFactor = 0.4;   // CL multiplier after stall (lift drops to 40%)

    // Drag
    this.cd0 = 0.03;              // parasitic drag coefficient (clean light aircraft)
    this.cdInducedK = 0.06;       // induced drag factor: CD_induced = K * CL²
    this.cdStall = 0.15;          // extra drag added during stall

    // Control authority — torque per unit input per unit dynamic pressure
    this.pitchAuthority = activeProfile.pitchAuthority;
    this.rollAuthority = activeProfile.rollAuthority;
    this.yawAuthority = activeProfile.yawAuthority;

    // Damping — angular velocity decay rate (1/s), higher = more stable
    this.pitchDamping = activeProfile.pitchDamping;
    this.rollDamping = activeProfile.rollDamping;
    this.yawDamping = activeProfile.yawDamping;

    // Stability
    this.trimAoA = activeProfile.trimAoA * Math.PI / 180;
    this.pitchStability = activeProfile.pitchStability;
    this.weathervaneStrength = activeProfile.weathervaneStrength;
    this.dihedralStrength = activeProfile.dihedralStrength;
    this.sideslipForce = 500;     // lateral force resisting sideslip (N per m/s)

    // Ground physics
    this.groundFriction = 0.03;     // rolling friction coefficient (tires on asphalt)
    this.takeoffSpeed = 60;         // m/s — minimum speed for takeoff
    this.noseWheelSteer = 0.8;      // yaw rate on ground (rad/s at full input)

    // Terrain callback — injected externally
    this.getGroundHeight = (x, z) => 0;

    // --- State ---
    this.reset();
  }

  reset() {
    this.position = new Vec3(0, 0, 0);          // on the runway
    this.velocity = new Vec3(0, 0, 0);          // stationary
    this.orientation = new Quat(0, 0, 0, 1);   // identity — level, facing -Z
    this.angularVelocity = new Vec3(0, 0, 0);   // rad/s in body frame

    this.throttle = 0;
    this.airspeed = 0;
    this.altitude = 0;
    this.verticalSpeed = 0;
    this.aoa = 0;
    this.isStalling = false;

    this.groundHeight = 0;
    this.agl = 0;

    this.onGround = true;
    this.crashed = false;

    // Landing gear state
    this.gearDown = true;
    this.gearProgress = 0;  // 0 = deployed, 1 = retracted

    // Auto-level
    this.autoLevel = activeProfile.autoLevel;

    // Inputs (set externally each frame)
    this.pitchInput = 0;   // -1 to 1
    this.rollInput = 0;    // -1 to 1
    this.yawInput = 0;     // -1 to 1
  }

  // Get aircraft's local axes in world space
  getForward() { return this.orientation.rotateVec(new Vec3(0, 0, -1)); }
  getUp()      { return this.orientation.rotateVec(new Vec3(0, 1, 0)); }
  getRight()   { return this.orientation.rotateVec(new Vec3(1, 0, 0)); }

  stepPhysics(dt) {
    if (this.crashed) return;

    const forward = this.getForward();
    const up = this.getUp();
    const right = this.getRight();

    // --- Airspeed & dynamic pressure ---
    this.airspeed = this.velocity.length();
    const dynamicPressure = 0.5 * this.airDensity * this.airspeed * this.airspeed;
    const qS = dynamicPressure * this.wingArea;

    // =============================================
    // GROUND MODE
    // =============================================
    if (this.onGround) {
      // Thrust along forward axis (taxi)
      const thrustMag = this.throttle * this.maxThrust;
      let totalForce = forward.scale(thrustMag);

      // Aerodynamic drag (still applies on ground)
      if (this.airspeed > 0.5) {
        const cd = this.cd0;
        const dragMag = cd * qS;
        const dragDir = this.velocity.normalize().scale(-1);
        totalForce = totalForce.add(dragDir.scale(dragMag));
      }

      // Ground friction — constant force opposing motion (rolling friction = μ * weight)
      if (this.airspeed > 0.1) {
        const frictionMag = this.groundFriction * this.mass * 9.81;
        const frictionForce = this.velocity.normalize().scale(-frictionMag);
        totalForce = totalForce.add(frictionForce);
      }

      // Acceleration
      const accel = totalForce.scale(1 / this.mass);
      this.velocity = this.velocity.add(accel.scale(dt));

      // Nose wheel steering — yaw proportional to input and speed
      if (this.airspeed > 0.5) {
        const steerRate = this.yawInput * this.noseWheelSteer;
        // Scale steering down at high speed for realism
        const speedFactor = Math.min(1, 10 / this.airspeed);
        const yawAngle = steerRate * speedFactor * dt;
        const yawQ = Quat.fromAxisAngle(new Vec3(0, 1, 0), yawAngle);
        this.orientation = yawQ.multiply(this.orientation).normalize();
        // Also rotate velocity to follow heading
        this.velocity = yawQ.rotateVec(this.velocity);
      }

      // Constrain orientation — force level (no roll, no pitch)
      // Rebuild quaternion from yaw only
      const fwd = this.getForward();
      const yaw = Math.atan2(fwd.x, -fwd.z);
      this.orientation = Quat.fromAxisAngle(new Vec3(0, 1, 0), yaw);

      // Kill angular velocity on ground
      this.angularVelocity.set(0, 0, 0);

      // Clamp to ground (terrain-relative)
      this.groundHeight = this.getGroundHeight(this.position.x, this.position.z);
      this.position.y = this.groundHeight;
      this.velocity.y = 0;

      // Update position
      this.position = this.position.add(this.velocity.scale(dt));
      this.groundHeight = this.getGroundHeight(this.position.x, this.position.z);
      this.position.y = this.groundHeight; // enforce after position update

      // Stop completely at very low speed with no throttle
      if (this.airspeed < 0.5 && this.throttle < 0.01) {
        this.velocity.set(0, 0, 0);
      }

      // Takeoff condition: speed > threshold AND pulling back on stick
      if (this.airspeed > this.takeoffSpeed && this.pitchInput > 0) {
        this.onGround = false;
        // Give slight upward pitch to generate lift
        const fwd2 = this.getForward();
        const yaw2 = Math.atan2(fwd2.x, -fwd2.z);
        const pitchUp = 5 * Math.PI / 180; // 5° nose up on takeoff
        this.orientation = Quat.fromAxisAngle(new Vec3(0, 1, 0), yaw2)
          .multiply(Quat.fromAxisAngle(new Vec3(1, 0, 0), pitchUp));
      }

      // AoA is zero on ground
      this.aoa = 0;
      this.isStalling = false;

      // Update derived values
      this.altitude = this.position.y;
      this.agl = this.position.y - this.groundHeight;
      this.verticalSpeed = 0;
      return;
    }

    // =============================================
    // FLIGHT MODE (existing physics)
    // =============================================

    // --- Angle of Attack ---
    if (this.airspeed > 0.5) {
      const velNorm = this.velocity.normalize();
      const forwardDot = velNorm.dot(forward);
      const upDot = velNorm.dot(up);
      this.aoa = Math.atan2(-upDot, forwardDot);
    } else {
      this.aoa = 0;
    }

    // --- Unified CL ---
    let cl;
    const absAoa = Math.abs(this.aoa);
    if (absAoa < this.stallAngle) {
      cl = this.clSlope * this.aoa;
      this.isStalling = false;
    } else {
      cl = this.clSlope * Math.sign(this.aoa) * this.stallAngle * this.postStallFactor;
      this.isStalling = true;
    }

    // --- Forces ---
    let totalForce = new Vec3(0, 0, 0);

    // 1. Gravity
    totalForce = totalForce.add(new Vec3(0, -9.81 * this.mass, 0));

    // 2. Thrust
    const thrustMag = this.throttle * this.maxThrust;
    totalForce = totalForce.add(forward.scale(thrustMag));

    // 3. Lift
    if (this.airspeed > 1) {
      const liftMag = cl * qS;
      const velDir = this.velocity.normalize();
      let liftDir = velDir.cross(right).normalize();
      if (liftDir.dot(up) < 0) liftDir = liftDir.scale(-1);
      totalForce = totalForce.add(liftDir.scale(liftMag));
    }

    // 4. Drag
    if (this.airspeed > 0.5) {
      const cdInduced = this.cdInducedK * cl * cl;
      let cd = this.cd0 + cdInduced;
      if (this.isStalling) cd += this.cdStall;
      // Gear drag penalty — deployed gear adds parasitic drag
      if (this.gearProgress < 1) cd += activeProfile.gearDragPenalty * (1 - this.gearProgress);
      const dragMag = cd * qS;
      const dragDir = this.velocity.normalize().scale(-1);
      totalForce = totalForce.add(dragDir.scale(dragMag));
    }

    // 5. Sideslip force
    if (this.airspeed > 1) {
      const velDir = this.velocity.normalize();
      const sideslip = velDir.dot(right);
      const sideslipForce = right.scale(-sideslip * this.sideslipForce * this.airspeed);
      totalForce = totalForce.add(sideslipForce);
    }

    // --- Acceleration ---
    const accel = totalForce.scale(1 / this.mass);
    this.velocity = this.velocity.add(accel.scale(dt));

    // --- Torques ---
    const authorityScale = Math.min(dynamicPressure / 3000, 1.5);

    const pitchTorque = this.pitchInput * this.pitchAuthority * authorityScale;
    const rollTorque = -this.rollInput * this.rollAuthority * authorityScale;
    let yawTorque = -this.yawInput * this.yawAuthority * authorityScale;

    const pitchStab = -(this.aoa - this.trimAoA) * this.pitchStability * authorityScale;

    if (this.airspeed > 1) {
      const velDir = this.velocity.normalize();
      const sideslip = Math.asin(Math.max(-1, Math.min(1, velDir.dot(right))));
      yawTorque += -sideslip * this.weathervaneStrength * authorityScale;
    }

    const worldUp = new Vec3(0, 1, 0);
    const bankDot = right.dot(worldUp);
    let dihedralTorque = -bankDot * this.dihedralStrength * authorityScale;

    // Auto-level: when enabled and no pitch/roll input, strengthen stability torques
    if (this.autoLevel && Math.abs(this.pitchInput) < 0.05 && Math.abs(this.rollInput) < 0.05) {
      const alStr = activeProfile.autoLevelStrength;
      dihedralTorque *= (1 + alStr);
      // Extra pitch stability toward trimAoA
      const extraPitchStab = -(this.aoa - this.trimAoA) * this.pitchStability * alStr * authorityScale;
      this.angularVelocity.x += extraPitchStab * dt;
    }

    this.angularVelocity.x += (pitchTorque + pitchStab) * dt;
    this.angularVelocity.y += yawTorque * dt;
    this.angularVelocity.z += (rollTorque + dihedralTorque) * dt;

    this.angularVelocity.x *= Math.exp(-this.pitchDamping * dt);
    this.angularVelocity.y *= Math.exp(-this.yawDamping * dt);
    this.angularVelocity.z *= Math.exp(-this.rollDamping * dt);

    const maxAngVel = 3.0;
    this.angularVelocity.x = Math.max(-maxAngVel, Math.min(maxAngVel, this.angularVelocity.x));
    this.angularVelocity.y = Math.max(-maxAngVel, Math.min(maxAngVel, this.angularVelocity.y));
    this.angularVelocity.z = Math.max(-maxAngVel, Math.min(maxAngVel, this.angularVelocity.z));

    // --- Apply rotation ---
    const omega = new Quat(
      this.angularVelocity.x,
      this.angularVelocity.y,
      this.angularVelocity.z,
      0
    );
    const qDot = this.orientation.multiply(omega);
    this.orientation = new Quat(
      this.orientation.x + qDot.x * 0.5 * dt,
      this.orientation.y + qDot.y * 0.5 * dt,
      this.orientation.z + qDot.z * 0.5 * dt,
      this.orientation.w + qDot.w * 0.5 * dt
    ).normalize();

    // --- Update position ---
    this.position = this.position.add(this.velocity.scale(dt));

    // --- Landing / Crash Detection (terrain-relative) ---
    this.groundHeight = this.getGroundHeight(this.position.x, this.position.z);
    if (this.position.y <= this.groundHeight) {
      const descentRate = -this.velocity.y; // positive = descending
      const fwd = this.getForward();
      const rt = this.getRight();
      const u = this.getUp();
      const pitchDeg = Math.asin(Math.max(-1, Math.min(1, fwd.y))) * 180 / Math.PI;
      const rollDeg = Math.atan2(-rt.dot(new Vec3(0, 1, 0)), u.dot(new Vec3(0, 1, 0))) * 180 / Math.PI;

      // Gear-up landing is always a crash
      if (this.gearProgress > 0.5) {
        this.crashed = true;
        this.position.y = this.groundHeight;
        this.velocity.set(0, 0, 0);
        this.angularVelocity.set(0, 0, 0);
      } else if (descentRate < 3 && Math.abs(pitchDeg) < 15 && Math.abs(rollDeg) < 30) {
        // Safe landing
        this.onGround = true;
        this.position.y = this.groundHeight;
        this.velocity.y = 0;
        this.angularVelocity.set(0, 0, 0);
        // Force gear deployed on ground
        this.gearDown = true;
        this.gearProgress = 0;
        // Rebuild orientation from yaw only (level the aircraft, preserve heading)
        const yaw = Math.atan2(fwd.x, -fwd.z);
        this.orientation = Quat.fromAxisAngle(new Vec3(0, 1, 0), yaw);
      } else {
        // Crash
        this.crashed = true;
        this.position.y = this.groundHeight;
        this.velocity.set(0, 0, 0);
        this.angularVelocity.set(0, 0, 0);
      }
    }

    // --- Velocity clamp ---
    const maxSpeed = 300;
    if (this.airspeed > maxSpeed) {
      this.velocity = this.velocity.normalize().scale(maxSpeed);
    }

    // --- Update derived values ---
    this.altitude = this.position.y;
    this.agl = this.position.y - this.groundHeight;
    this.verticalSpeed = this.velocity.y;
  }
}

// ============================================================
// Input Handler — keyboard with smoothing
// ============================================================
class InputHandler {
  constructor() {
    this.keys = {};
    this.smoothPitch = 0;
    this.smoothRoll = 0;
    this.smoothYaw = 0;
    this.rampRate = 5.0; // ramp toward target at 5/s

    window.addEventListener('keydown', (e) => {
      this.keys[e.code] = true;
      e.preventDefault();
    });
    window.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
      e.preventDefault();
    });
  }

  update(dt, model) {
    // Raw target inputs
    let targetPitch = 0;
    let targetRoll = 0;
    let targetYaw = 0;

    if (this.keys['ArrowUp'])    targetPitch = -1; // push forward = nose down
    if (this.keys['ArrowDown'])  targetPitch =  1; // pull back = nose up
    if (this.keys['ArrowLeft'])  targetRoll  = -1; // roll left
    if (this.keys['ArrowRight']) targetRoll  =  1; // roll right
    if (this.keys['KeyA'])       targetYaw   = -1; // yaw left
    if (this.keys['KeyD'])       targetYaw   =  1; // yaw right

    // Throttle — adjust and clamp (persists)
    const throttleRate = 0.5; // 0 to 1 in 2 seconds
    if (this.keys['KeyW']) model.throttle = Math.min(1, model.throttle + throttleRate * dt);
    if (this.keys['KeyS']) model.throttle = Math.max(0, model.throttle - throttleRate * dt);

    // Smooth ramp toward targets
    this.smoothPitch = this._ramp(this.smoothPitch, targetPitch, dt);
    this.smoothRoll  = this._ramp(this.smoothRoll, targetRoll, dt);
    this.smoothYaw   = this._ramp(this.smoothYaw, targetYaw, dt);

    model.pitchInput = this.smoothPitch;
    model.rollInput  = this.smoothRoll;
    model.yawInput   = this.smoothYaw;
  }

  _ramp(current, target, dt) {
    const diff = target - current;
    const step = this.rampRate * dt;
    if (Math.abs(diff) < step) return target;
    return current + Math.sign(diff) * step;
  }
}

// ============================================================
// Debug Panel — old HUD (toggled with backtick)
// ============================================================
let debugPanelVisible = false;

function updateDebugPanel(model) {
  if (!debugPanelVisible) return;

  const forward = model.getForward();
  const up = model.getUp();
  const right = model.getRight();
  const worldUp = new Vec3(0, 1, 0);
  const pitchDeg = Math.asin(Math.max(-1, Math.min(1, forward.y))) * 180 / Math.PI;
  const rollDeg = Math.atan2(-right.dot(worldUp), up.dot(worldUp)) * 180 / Math.PI;
  let headingDeg = Math.atan2(forward.x, -forward.z) * 180 / Math.PI;
  if (headingDeg < 0) headingDeg += 360;

  const M_TO_FT = 3.28084;
  const MS_TO_KT = 1.94384;
  const MS_TO_FPM = 196.85;

  document.getElementById('alt').textContent   = (model.altitude * M_TO_FT).toFixed(0) + ' ft';
  const aglEl = document.getElementById('agl');
  aglEl.textContent = (model.agl * M_TO_FT).toFixed(0) + ' ft';
  if (!model.onGround && model.agl < 50) aglEl.style.color = '#f00';
  else if (!model.onGround && model.agl < 150) aglEl.style.color = '#ff0';
  else aglEl.style.color = '#0f0';

  document.getElementById('spd').textContent   = (model.airspeed * MS_TO_KT).toFixed(0) + ' kt';
  document.getElementById('vs').textContent    = (model.verticalSpeed * MS_TO_FPM).toFixed(0) + ' fpm';
  document.getElementById('pitch').textContent = pitchDeg.toFixed(1) + '°';
  document.getElementById('roll').textContent  = rollDeg.toFixed(1) + '°';
  document.getElementById('hdg').textContent   = headingDeg.toFixed(0) + '°';
  document.getElementById('thr').textContent   = (model.throttle * 100).toFixed(0) + '%';
  document.getElementById('aoa').textContent   = (model.aoa * 180 / Math.PI).toFixed(1) + '°';

  document.getElementById('horizon-ball').style.transform =
    `rotate(${-rollDeg}deg) translateY(${pitchDeg * 1.5}px)`;
  document.getElementById('throttle-fill').style.height = (model.throttle * 100) + '%';

  const stallEl = document.getElementById('stall');
  stallEl.className = model.isStalling ? 'stall active' : 'stall';

  const stateEl = document.getElementById('flight-state');
  if (model.crashed) stateEl.innerHTML = '<span class="state-badge" style="background:#550000;color:#ff4444;">CRASH</span>';
  else if (model.onGround) stateEl.innerHTML = '<span class="state-badge gnd">GND</span>';
  else stateEl.innerHTML = '<span class="state-badge air">AIR</span>';
}

// ============================================================
// Flight HUD — fighter-jet overlay
// ============================================================
const HUD_CONST = {
  M_TO_FT: 3.28084,
  MS_TO_KT: 1.94384,
  MS_TO_FPM: 196.85,
  PX_PER_DEG: 12,              // pitch ladder spacing
  HDG_FOV_DEG: 60,              // heading tape visible range
  HDG_TICK_STEP: 5,
  SPD_RANGE_KT: 100,
  SPD_TICK_STEP: 10,
  ALT_RANGE_FT: 2000,
  ALT_TICK_STEP: 100,
  CARDINALS: { 0: 'N', 90: 'E', 180: 'S', 270: 'W' }
};

const hudPools = {};

function initFlightHUD() {
  // --- Heading tape pool ---
  const hdgStrip = document.getElementById('heading-tape-strip');
  hudPools.hdgTicks = [];
  hudPools.hdgLabels = [];
  for (let i = 0; i < 16; i++) {
    const tick = document.createElement('div');
    tick.className = 'hdg-tick';
    hdgStrip.appendChild(tick);
    hudPools.hdgTicks.push(tick);
    const label = document.createElement('div');
    label.className = 'hdg-label';
    hdgStrip.appendChild(label);
    hudPools.hdgLabels.push(label);
  }

  // --- Pitch ladder static lines ---
  const ladder = document.getElementById('pitch-ladder');
  const pitchMarks = [-30, -20, -15, -10, -5, 0, 5, 10, 15, 20, 30];
  pitchMarks.forEach(deg => {
    const line = document.createElement('div');
    line.className = 'pitch-line';
    line.style.position = 'absolute';
    line.style.left = '50%';
    if (deg === 0) {
      line.classList.add('horizon');
    } else {
      const w = Math.abs(deg) >= 20 ? 140 : (Math.abs(deg) >= 10 ? 100 : 60);
      line.style.width = w + 'px';
      line.style.marginLeft = (-w / 2) + 'px';
      if (deg > 0) line.classList.add('above');
      else line.classList.add('below');
      // Labels
      const ll = document.createElement('span');
      ll.className = 'pitch-deg-label left';
      ll.textContent = Math.abs(deg);
      line.appendChild(ll);
      const lr = document.createElement('span');
      lr.className = 'pitch-deg-label right';
      lr.textContent = Math.abs(deg);
      line.appendChild(lr);
    }
    // Position: positive deg = above center = negative Y offset
    // We'll set these relative to center (50%); base offset from pitch-ladder transform
    line.style.top = '50%';
    line.style.marginTop = (-deg * HUD_CONST.PX_PER_DEG) + 'px';
    ladder.appendChild(line);
  });

  // --- Speed tape pool ---
  const spdStrip = document.getElementById('speed-tape-strip');
  hudPools.spdTicks = [];
  hudPools.spdLabels = [];
  for (let i = 0; i < 24; i++) {
    const tick = document.createElement('div');
    tick.className = 'spd-tick';
    spdStrip.appendChild(tick);
    hudPools.spdTicks.push(tick);
    const label = document.createElement('div');
    label.className = 'spd-label';
    spdStrip.appendChild(label);
    hudPools.spdLabels.push(label);
  }

  // --- Altitude tape pool ---
  const altStrip = document.getElementById('alt-tape-strip');
  hudPools.altTicks = [];
  hudPools.altLabels = [];
  for (let i = 0; i < 24; i++) {
    const tick = document.createElement('div');
    tick.className = 'alt-tick';
    altStrip.appendChild(tick);
    hudPools.altTicks.push(tick);
    const label = document.createElement('div');
    label.className = 'alt-label';
    altStrip.appendChild(label);
    hudPools.altLabels.push(label);
  }

  // Cache DOM refs
  hudPools.dom = {
    headingReadout: document.getElementById('heading-readout'),
    pitchLadder: document.getElementById('pitch-ladder'),
    speedReadout: document.getElementById('speed-readout'),
    altReadout: document.getElementById('alt-readout'),
    aglValue: document.getElementById('agl-value'),
    aglReadout: document.getElementById('agl-readout'),
    throttleFill: document.getElementById('hud-throttle-fill'),
    vsReadout: document.getElementById('vs-readout'),
    fpm: document.getElementById('fpm'),
    hudStall: document.getElementById('hud-stall'),
    hudState: document.getElementById('hud-state'),
    headingTape: document.getElementById('heading-tape'),
    speedTape: document.getElementById('speed-tape'),
    altTape: document.getElementById('alt-tape'),
    gearIndicator: document.getElementById('hud-gear'),
    autoLevelIndicator: document.getElementById('hud-autolevel'),
  };
}

function updateHUD(model) {
  const dom = hudPools.dom;

  // Extract angles
  const forward = model.getForward();
  const up = model.getUp();
  const right = model.getRight();
  const worldUp = new Vec3(0, 1, 0);

  const pitchDeg = Math.asin(Math.max(-1, Math.min(1, forward.y))) * 180 / Math.PI;
  const rollDeg = Math.atan2(-right.dot(worldUp), up.dot(worldUp)) * 180 / Math.PI;
  let headingDeg = Math.atan2(forward.x, -forward.z) * 180 / Math.PI;
  if (headingDeg < 0) headingDeg += 360;

  const speedKt = model.airspeed * HUD_CONST.MS_TO_KT;
  const altFt = model.altitude * HUD_CONST.M_TO_FT;
  const aglFt = model.agl * HUD_CONST.M_TO_FT;
  const vsFpm = model.verticalSpeed * HUD_CONST.MS_TO_FPM;

  // === Heading Tape ===
  const hdgTapeW = dom.headingTape.clientWidth;
  const pxPerHdgDeg = hdgTapeW / HUD_CONST.HDG_FOV_DEG;
  const halfFov = HUD_CONST.HDG_FOV_DEG / 2;
  const centerHdg = headingDeg;

  // Find nearest 5-deg tick
  const firstTick = Math.floor((centerHdg - halfFov - 5) / HUD_CONST.HDG_TICK_STEP) * HUD_CONST.HDG_TICK_STEP;
  for (let i = 0; i < hudPools.hdgTicks.length; i++) {
    const tickDeg = firstTick + i * HUD_CONST.HDG_TICK_STEP;
    let offset = tickDeg - centerHdg;
    // Wrap around 360
    if (offset > 180) offset -= 360;
    if (offset < -180) offset += 360;
    const px = hdgTapeW / 2 + offset * pxPerHdgDeg;

    const tick = hudPools.hdgTicks[i];
    const label = hudPools.hdgLabels[i];

    if (px < -20 || px > hdgTapeW + 20) {
      tick.style.display = 'none';
      label.style.display = 'none';
      continue;
    }

    tick.style.display = '';
    tick.style.left = px + 'px';

    let normDeg = ((tickDeg % 360) + 360) % 360;
    const isMajor = normDeg % 10 === 0;
    tick.className = isMajor ? 'hdg-tick major' : 'hdg-tick';

    if (isMajor) {
      label.style.display = '';
      label.style.left = px + 'px';
      label.textContent = String(normDeg).padStart(3, '0');
    } else {
      label.style.display = 'none';
    }
  }

  // Readout shows cardinal/intercardinal direction
  const hdgRound = Math.round(headingDeg) % 360;
  const cardinals8 = ['N','NE','E','SE','S','SW','W','NW'];
  const cardIdx = Math.round(hdgRound / 45) % 8;
  dom.headingReadout.textContent = cardinals8[cardIdx];

  // === Pitch Ladder ===
  dom.pitchLadder.style.transform =
    `translateY(${pitchDeg * HUD_CONST.PX_PER_DEG}px)`;

  // === Speed Tape ===
  const spdTapeH = dom.speedTape.clientHeight;
  const pxPerKt = spdTapeH / HUD_CONST.SPD_RANGE_KT;
  const spdHalf = HUD_CONST.SPD_RANGE_KT / 2;
  const firstSpdTick = Math.floor((speedKt - spdHalf - 10) / HUD_CONST.SPD_TICK_STEP) * HUD_CONST.SPD_TICK_STEP;

  for (let i = 0; i < hudPools.spdTicks.length; i++) {
    const tickVal = firstSpdTick + i * HUD_CONST.SPD_TICK_STEP;
    const offset = tickVal - speedKt; // positive = tick above center (speed increases up)
    const py = spdTapeH / 2 - offset * pxPerKt;

    const tick = hudPools.spdTicks[i];
    const label = hudPools.spdLabels[i];

    if (py < -20 || py > spdTapeH + 20 || tickVal < 0) {
      tick.style.display = 'none';
      label.style.display = 'none';
      continue;
    }

    tick.style.display = '';
    tick.style.top = py + 'px';

    const isMajor = tickVal % 20 === 0;
    tick.className = isMajor ? 'spd-tick major' : 'spd-tick';

    if (isMajor) {
      label.style.display = '';
      label.style.top = py + 'px';
      label.textContent = tickVal;
    } else {
      label.style.display = 'none';
    }
  }

  dom.speedReadout.textContent = Math.round(speedKt);

  // === Altitude Tape ===
  const altTapeH = dom.altTape.clientHeight;
  const pxPerFt = altTapeH / HUD_CONST.ALT_RANGE_FT;
  const altHalf = HUD_CONST.ALT_RANGE_FT / 2;
  const firstAltTick = Math.floor((altFt - altHalf - 100) / HUD_CONST.ALT_TICK_STEP) * HUD_CONST.ALT_TICK_STEP;

  for (let i = 0; i < hudPools.altTicks.length; i++) {
    const tickVal = firstAltTick + i * HUD_CONST.ALT_TICK_STEP;
    const offset = tickVal - altFt; // positive = tick above center (alt increases up)
    const py = altTapeH / 2 - offset * pxPerFt;

    const tick = hudPools.altTicks[i];
    const label = hudPools.altLabels[i];

    if (py < -20 || py > altTapeH + 20 || tickVal < 0) {
      tick.style.display = 'none';
      label.style.display = 'none';
      continue;
    }

    tick.style.display = '';
    tick.style.top = py + 'px';

    const isMajor = tickVal % 500 === 0;
    tick.className = isMajor ? 'alt-tick major' : 'alt-tick';

    if (isMajor) {
      label.style.display = '';
      label.style.top = py + 'px';
      label.textContent = tickVal;
    } else {
      label.style.display = 'none';
    }
  }

  dom.altReadout.textContent = Math.round(altFt);

  // === AGL Readout ===
  dom.aglValue.textContent = Math.round(aglFt);
  if (!model.onGround && model.agl < 50) {
    dom.aglReadout.style.color = '#ff0000';
  } else if (!model.onGround && model.agl < 150) {
    dom.aglReadout.style.color = '#ffff00';
  } else {
    dom.aglReadout.style.color = '#00ff00';
  }

  // === Throttle ===
  dom.throttleFill.style.height = (model.throttle * 100) + '%';

  // === Vertical Speed ===
  const vsAbs = Math.abs(Math.round(vsFpm));
  const vsArrow = vsFpm > 10 ? '\u25B2' : (vsFpm < -10 ? '\u25BC' : '');
  dom.vsReadout.textContent = vsArrow + ' ' + vsAbs;

  // === Flight Path Marker ===
  if (model.onGround || model.airspeed < 5) {
    dom.fpm.style.display = 'none';
  } else {
    dom.fpm.style.display = '';
    const velDir = model.velocity.normalize();
    const fpmPitch = Math.atan2(-velDir.dot(up), velDir.dot(forward)) * 180 / Math.PI;
    const fpmYaw = Math.asin(Math.max(-1, Math.min(1, velDir.dot(right)))) * 180 / Math.PI;

    // Convert to pixel offset from screen center
    const fpmX = fpmYaw * HUD_CONST.PX_PER_DEG;
    const fpmY = -fpmPitch * HUD_CONST.PX_PER_DEG; // pitch up = move up on screen

    // Clamp to viewport
    const maxX = window.innerWidth / 2 - 30;
    const maxY = window.innerHeight / 2 - 30;
    const cx = Math.max(-maxX, Math.min(maxX, fpmX));
    const cy = Math.max(-maxY, Math.min(maxY, fpmY));

    dom.fpm.style.left = (window.innerWidth / 2 + cx - 8) + 'px';
    dom.fpm.style.top = (window.innerHeight / 2 + cy - 8) + 'px';
  }

  // === Stall Warning ===
  dom.hudStall.style.display = model.isStalling ? '' : 'none';

  // === State Indicator ===
  if (model.crashed) {
    dom.hudState.textContent = 'CRASH';
    dom.hudState.style.color = '#ff0000';
  } else if (model.onGround) {
    dom.hudState.textContent = 'GND';
    dom.hudState.style.color = '#ffaa00';
  } else {
    dom.hudState.textContent = 'AIR';
    dom.hudState.style.color = '#00aaff';
  }

  // === Gear Indicator ===
  if (model.gearProgress === 0) {
    dom.gearIndicator.textContent = 'GEAR DN';
    dom.gearIndicator.style.color = '#00ff00';
  } else if (model.gearProgress === 1) {
    dom.gearIndicator.textContent = 'GEAR UP';
    dom.gearIndicator.style.color = '#666666';
  } else {
    dom.gearIndicator.textContent = model.gearDown ? 'GEAR DN' : 'GEAR UP';
    dom.gearIndicator.style.color = '#ffaa00'; // amber during transit
  }

  // === Auto-Level Indicator ===
  dom.autoLevelIndicator.style.display = model.autoLevel ? '' : 'none';

  // Crash overlay
  const crashOverlay = document.getElementById('crash-overlay');
  crashOverlay.className = model.crashed ? 'visible' : '';

  // Update debug panel if visible
  updateDebugPanel(model);
}

// ============================================================
// TerrainManager — chunked terrain with LOD and ocean boundary
// ============================================================
class TerrainManager {
  constructor(scene, shadowGen) {
    this.scene = scene;
    this.shadowGen = shadowGen;
    this.chunks = new Map();
    this.pendingQueue = [];
    this.CHUNK_SIZE = 2000;
    this.LOAD_RADIUS = 14000;
    this.UNLOAD_RADIUS = 16000;

    // LOD levels: [maxDistance, subdivisions, textureSize]
    this.LOD_LEVELS = [
      { maxDist: 4000, subs: 50, texSize: 128 },
      { maxDist: 8000, subs: 24, texSize: 64 },
      { maxDist: 14000, subs: 12, texSize: 32 }
    ];

    // Ocean plane
    const ocean = BABYLON.MeshBuilder.CreateGround('ocean', {
      width: 60000, height: 60000, subdivisions: 1
    }, scene);
    ocean.position.y = -0.5;
    const oceanMat = new BABYLON.PBRMetallicRoughnessMaterial('oceanMat', scene);
    oceanMat.baseColor = new BABYLON.Color3(0.05, 0.12, 0.2);
    oceanMat.metallic = 0.0;
    oceanMat.roughness = 0.2;
    ocean.material = oceanMat;
    this.ocean = ocean;
  }

  _getLOD(dist) {
    for (let i = 0; i < this.LOD_LEVELS.length; i++) {
      if (dist < this.LOD_LEVELS[i].maxDist) return i;
    }
    return this.LOD_LEVELS.length - 1;
  }

  _chunkKey(gx, gz) {
    return gx + ',' + gz;
  }

  _chunkCenter(gx, gz) {
    return {
      x: gx * this.CHUNK_SIZE + this.CHUNK_SIZE * 0.5,
      z: gz * this.CHUNK_SIZE + this.CHUNK_SIZE * 0.5
    };
  }

  update(playerX, playerZ) {
    const CS = this.CHUNK_SIZE;
    const loadR = this.LOAD_RADIUS;
    const unloadR = this.UNLOAD_RADIUS;

    // Grid range to check
    const minGX = Math.floor((playerX - loadR) / CS);
    const maxGX = Math.floor((playerX + loadR) / CS);
    const minGZ = Math.floor((playerZ - loadR) / CS);
    const maxGZ = Math.floor((playerZ + loadR) / CS);

    // 1. Find chunks to load
    const needed = new Set();
    for (let gx = minGX; gx <= maxGX; gx++) {
      for (let gz = minGZ; gz <= maxGZ; gz++) {
        const center = this._chunkCenter(gx, gz);
        const dx = center.x - playerX;
        const dz = center.z - playerZ;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < loadR) {
          const key = this._chunkKey(gx, gz);
          needed.add(key);
          if (!this.chunks.has(key)) {
            this.pendingQueue.push({ gx, gz, dist, key });
          }
        }
      }
    }

    // 2. Remove chunks beyond unload radius
    for (const [key, chunk] of this.chunks) {
      const center = this._chunkCenter(chunk.gridX, chunk.gridZ);
      const dx = center.x - playerX;
      const dz = center.z - playerZ;
      const dist = Math.sqrt(dx * dx + dz * dz);
      if (dist > unloadR) {
        this._removeChunk(key);
      }
    }

    // 3. Sort pending by distance, remove duplicates
    this.pendingQueue = this.pendingQueue.filter(p => !this.chunks.has(p.key));
    this.pendingQueue.sort((a, b) => a.dist - b.dist);

    // 4. Create up to 2 chunks per frame with time budget
    const startTime = performance.now();
    let created = 0;
    while (this.pendingQueue.length > 0 && created < 2) {
      if (created > 0 && performance.now() - startTime > 8) break;
      const p = this.pendingQueue.shift();
      if (!this.chunks.has(p.key)) {
        const lod = this._getLOD(p.dist);
        this._createChunk(p.gx, p.gz, lod);
        created++;
      }
    }

    // 5. LOD upgrade — max 1 per frame
    let upgraded = false;
    for (const [key, chunk] of this.chunks) {
      if (upgraded) break;
      const center = this._chunkCenter(chunk.gridX, chunk.gridZ);
      const dx = center.x - playerX;
      const dz = center.z - playerZ;
      const dist = Math.sqrt(dx * dx + dz * dz);
      const desiredLOD = this._getLOD(dist);
      if (desiredLOD < chunk.lod) {
        this._removeChunk(key);
        this._createChunk(chunk.gridX, chunk.gridZ, desiredLOD);
        upgraded = true;
      }
    }
  }

  _createChunk(gx, gz, lodLevel) {
    const CS = this.CHUNK_SIZE;
    const lod = this.LOD_LEVELS[lodLevel];
    const worldX = gx * CS;
    const worldZ = gz * CS;

    const mesh = BABYLON.MeshBuilder.CreateGround('chunk_' + gx + '_' + gz, {
      width: CS, height: CS,
      subdivisions: lod.subs,
      updatable: false
    }, this.scene);

    // Position chunk center
    mesh.position.x = worldX + CS * 0.5;
    mesh.position.z = worldZ + CS * 0.5;

    // Set vertex heights
    const positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
    for (let i = 0; i < positions.length; i += 3) {
      const absX = positions[i] + mesh.position.x;
      const absZ = positions[i + 2] + mesh.position.z;
      positions[i + 1] = getTerrainHeightBounded(absX, absZ);
    }
    mesh.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions);

    // Recompute and flip normals (right-handed system)
    const normals = [];
    BABYLON.VertexData.ComputeNormals(
      positions,
      mesh.getIndices(),
      normals
    );
    for (let i = 0; i < normals.length; i++) normals[i] = -normals[i];
    mesh.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals);

    // Per-chunk texture
    const texture = generateTerrainTexture(this.scene, worldX, worldZ, CS, lod.texSize);
    const material = new BABYLON.PBRMetallicRoughnessMaterial('chunkMat_' + gx + '_' + gz, this.scene);
    material.baseTexture = texture;
    material.metallic = 0.0;
    material.roughness = 0.85;
    mesh.material = material;
    mesh.receiveShadows = true;

    const key = this._chunkKey(gx, gz);
    this.chunks.set(key, { mesh, material, texture, gridX: gx, gridZ: gz, lod: lodLevel });
  }

  _removeChunk(key) {
    const chunk = this.chunks.get(key);
    if (!chunk) return;
    chunk.mesh.dispose();
    chunk.material.dispose();
    chunk.texture.dispose();
    this.chunks.delete(key);
  }

  getHeightAt(x, z) {
    return getTerrainHeightBounded(x, z);
  }
}

// ============================================================
// Babylon.js Scene Setup
// ============================================================
function createScene(engine) {
  const scene = new BABYLON.Scene(engine);
  scene.useRightHandedSystem = true;

  // Clear color (sky blue)
  scene.clearColor = new BABYLON.Color4(0.53, 0.72, 0.88, 1);

  // PBR environment texture for reflections
  scene.environmentTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(
    "https://assets.babylonjs.com/environments/environmentSpecular.env", scene
  );
  scene.environmentIntensity = 0.7;

  // Lights
  const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), scene);
  hemi.intensity = 0.4;

  const sun = new BABYLON.DirectionalLight('sun', new BABYLON.Vector3(-0.5, -1, -0.3), scene);
  sun.intensity = 1.0;

  // Chunked terrain manager (replaces single ground mesh)
  const terrainManager = new TerrainManager(scene, null); // shadowGen set after creation

  // Runway — 30m wide, 800m long, along -Z axis
  const runway = BABYLON.MeshBuilder.CreateGround('runway', { width: 30, height: 800 }, scene);
  runway.position.y = 0.01; // slightly above ground to prevent z-fighting
  runway.position.z = -400; // centered so aircraft starts at near end
  runway.renderingGroupId = 1;

  // Runway material with center dashed line via DynamicTexture
  const runwayMat = new BABYLON.StandardMaterial('runwayMat', scene);
  const runwayTex = new BABYLON.DynamicTexture('runwayTex', { width: 128, height: 2048 }, scene);
  const rctx = runwayTex.getContext();
  // Dark gray asphalt
  rctx.fillStyle = '#333338';
  rctx.fillRect(0, 0, 128, 2048);
  // White edge lines
  rctx.fillStyle = '#cccccc';
  rctx.fillRect(4, 0, 3, 2048);     // left edge
  rctx.fillRect(121, 0, 3, 2048);   // right edge
  // Center dashed line
  rctx.fillStyle = '#ffffff';
  for (let i = 0; i < 2048; i += 64) {
    rctx.fillRect(62, i, 4, 40);    // 40px dash, 24px gap
  }
  // Threshold markings at start
  rctx.fillStyle = '#ffffff';
  for (let s = 0; s < 8; s++) {
    const sx = 16 + s * 12;
    rctx.fillRect(sx, 1980, 8, 60);
  }
  runwayTex.update();
  runwayMat.diffuseTexture = runwayTex;
  runwayMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
  runway.material = runwayMat;

  // SkyMaterial — physically-based Rayleigh scattering sky
  const skybox = BABYLON.MeshBuilder.CreateBox('skyBox', { size: 10000 }, scene);
  const skyMat = new BABYLON.SkyMaterial('skyMat', scene);
  skyMat.backFaceCulling = false;
  skyMat.luminance = 1.0;
  skyMat.turbidity = 3;
  skyMat.rayleigh = 1.5;
  skyMat.mieCoefficient = 0.005;
  skyMat.mieDirectionalG = 0.8;
  skyMat.useSunPosition = true;
  skyMat.sunPosition = new BABYLON.Vector3(-50, 100, -30);
  skybox.material = skyMat;
  skybox.infiniteDistance = true;

  // Align directional light with sky sun
  const sunDir = skyMat.sunPosition.negate().normalize();
  sun.direction = sunDir;

  // Fog — exponential for natural atmospheric depth
  scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
  scene.fogDensity = 0.00005;
  scene.fogColor = new BABYLON.Color3(0.76, 0.84, 0.90);

  // Cascaded Shadow Generator
  const shadowGen = new BABYLON.CascadedShadowGenerator(2048, sun);
  shadowGen.bias = 0.005;
  shadowGen.normalBias = 0.02;
  shadowGen.lambda = 0.9;
  shadowGen.cascadeBlendPercentage = 0.1;
  shadowGen.stabilizeCascades = true;
  terrainManager.shadowGen = shadowGen;
  terrainManager.update(0, 0); // initial load around origin

  // Cloud layer
  const cloudPlane = BABYLON.MeshBuilder.CreateGround('clouds', { width: 20000, height: 20000, subdivisions: 1 }, scene);
  cloudPlane.position.y = 2500;
  const cloudMat = new BABYLON.StandardMaterial('cloudMat', scene);
  cloudMat.disableLighting = true;
  cloudMat.backFaceCulling = false;
  const cloudTex = new BABYLON.DynamicTexture('cloudTex', { width: 1024, height: 1024 }, scene);
  const cctx = cloudTex.getContext();
  const cloudImgData = cctx.createImageData(1024, 1024);
  for (let cy = 0; cy < 1024; cy++) {
    for (let cx = 0; cx < 1024; cx++) {
      const u = cx / 1024;
      const v = cy / 1024;
      // Multi-octave noise for cloud shapes
      let cloudNoise = 0;
      cloudNoise += simplex.noise2D(u * 4, v * 4) * 0.5;
      cloudNoise += simplex.noise2D(u * 8 + 100, v * 8 + 100) * 0.25;
      cloudNoise += simplex.noise2D(u * 16 + 200, v * 16 + 200) * 0.125;
      // Remap to [0,1] and apply threshold for cloud shapes
      const cloudVal = (cloudNoise + 0.5);
      const cloudAlpha = Math.max(0, Math.min(1, (cloudVal - 0.3) / 0.4));
      const ci = (cy * 1024 + cx) * 4;
      cloudImgData.data[ci] = 255;
      cloudImgData.data[ci + 1] = 255;
      cloudImgData.data[ci + 2] = 255;
      cloudImgData.data[ci + 3] = (cloudAlpha * 180) | 0;
    }
  }
  cctx.putImageData(cloudImgData, 0, 0);
  cloudTex.update();
  cloudMat.diffuseTexture = cloudTex;
  cloudMat.opacityTexture = cloudTex;
  cloudMat.useAlphaFromDiffuseTexture = true;
  cloudMat.emissiveColor = new BABYLON.Color3(0.95, 0.95, 0.95);
  cloudPlane.material = cloudMat;
  cloudPlane.renderingGroupId = 0;

  return { scene, shadowGen, terrainManager, cloudPlane };
}

// ============================================================
// Aircraft Mesh — detailed procedural aircraft with control surfaces
// ============================================================
function createAircraftMesh(scene) {
  const root = new BABYLON.TransformNode('aircraft', scene);

  // Body offset: gear strut (1.0) + wheel (0.25) + clearance (0.15)
  const body = new BABYLON.TransformNode('body', scene);
  body.parent = root;
  body.position.y = 1.4;

  // === PBR Materials ===
  const fuselageMat = new BABYLON.PBRMetallicRoughnessMaterial('fuselageMat', scene);
  fuselageMat.baseColor = BABYLON.Color3.FromHexString('#C0C8D0');
  fuselageMat.metallic = 0.85;
  fuselageMat.roughness = 0.3;

  const canopyMat = new BABYLON.PBRMetallicRoughnessMaterial('canopyMat', scene);
  canopyMat.baseColor = BABYLON.Color3.FromHexString('#88AACC');
  canopyMat.metallic = 0.1;
  canopyMat.roughness = 0.1;
  canopyMat.alpha = 0.35;

  const surfaceMat = new BABYLON.PBRMetallicRoughnessMaterial('surfaceMat', scene);
  surfaceMat.baseColor = BABYLON.Color3.FromHexString('#B0B8C0');
  surfaceMat.metallic = 0.8;
  surfaceMat.roughness = 0.35;

  const strutMat = new BABYLON.PBRMetallicRoughnessMaterial('strutMat', scene);
  strutMat.baseColor = BABYLON.Color3.FromHexString('#404040');
  strutMat.metallic = 0.7;
  strutMat.roughness = 0.5;

  const wheelMat = new BABYLON.PBRMetallicRoughnessMaterial('wheelMat', scene);
  wheelMat.baseColor = BABYLON.Color3.FromHexString('#202020');
  wheelMat.metallic = 0.0;
  wheelMat.roughness = 0.9;

  // === Fuselage — CreateTube with radiusFunction for smooth tapering ===
  const fusePoints = 20;
  const fuseLength = 10;
  const fusePath = [];
  for (let i = 0; i <= fusePoints; i++) {
    const t = i / fusePoints;
    fusePath.push(new BABYLON.Vector3(0, 0, -fuseLength / 2 + t * fuseLength));
  }
  const fuselage = BABYLON.MeshBuilder.CreateTube('fuselage', {
    path: fusePath,
    radiusFunction: (i) => {
      const t = i / fusePoints;
      // Smooth taper: wide in middle, narrow at nose/tail
      if (t < 0.15) {
        // Nose taper
        const nt = t / 0.15;
        return 0.1 + 0.5 * Math.sin(nt * Math.PI / 2);
      } else if (t > 0.75) {
        // Tail taper
        const tt = (t - 0.75) / 0.25;
        return 0.6 * (1 - tt * 0.7);
      }
      return 0.6;
    },
    tessellation: 16,
    cap: BABYLON.Mesh.CAP_ALL,
  }, scene);
  fuselage.material = fuselageMat;
  fuselage.parent = body;

  // === Canopy — hemisphere on top of forward fuselage ===
  const canopy = BABYLON.MeshBuilder.CreateSphere('canopy', { diameter: 1.6, segments: 12 }, scene);
  canopy.scaling = new BABYLON.Vector3(0.6, 0.5, 1.0);
  canopy.position.set(0, 0.45, -2.0);
  canopy.material = canopyMat;
  canopy.parent = body;

  // === Wings (left + right) — CreateRibbon for tapered planform ===
  function createWing(name, side) {
    const sign = side === 'left' ? -1 : 1;
    const span = 6;
    const rootChord = 2.0;
    const tipChord = 0.8;
    const sweep = 0.4; // trailing edge sweep
    const thickness = 0.08;
    const steps = 10;

    const topPath = [];
    const botPath = [];
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const y = sign * t * span;
      const chord = rootChord + (tipChord - rootChord) * t;
      const leadZ = -chord / 2 - sweep * t;
      const midZ = leadZ + chord / 2;
      // Airfoil-like: thicker at root, thinner at tip
      const h = thickness * (1 - 0.5 * t);
      topPath.push(new BABYLON.Vector3(y, h, midZ));
      botPath.push(new BABYLON.Vector3(y, -h, midZ));
    }

    // Build ribbon from leading edge -> top -> trailing edge -> bottom -> leading edge
    const pathArray = [topPath, botPath];
    const wing = BABYLON.MeshBuilder.CreateRibbon(name, {
      pathArray: pathArray,
      closePath: false,
      sideOrientation: BABYLON.Mesh.DOUBLESIDE,
    }, scene);
    wing.position.set(0, -0.1, -0.5);
    wing.material = fuselageMat;
    wing.parent = body;
    return wing;
  }

  const leftWing = createWing('leftWing', 'left');
  const rightWing = createWing('rightWing', 'right');

  // === Ailerons — small boxes at trailing edge of outer wing ===
  function createAileron(name, xPos) {
    // Hinge node at leading edge of aileron
    const hinge = new BABYLON.TransformNode(name + 'Hinge', scene);
    hinge.position.set(xPos, -0.1, 0.1);
    hinge.parent = body;
    const aileron = BABYLON.MeshBuilder.CreateBox(name, {
      width: 2.0, height: 0.06, depth: 0.4
    }, scene);
    // Offset so rotation appears at leading edge
    aileron.position.set(0, 0, 0.2);
    aileron.material = surfaceMat;
    aileron.parent = hinge;
    return hinge;
  }

  const leftAileron = createAileron('leftAileron', -4.5);
  const rightAileron = createAileron('rightAileron', 4.5);

  // === Horizontal Stabilizer — tapered ribbon ===
  function createHStab(name, side) {
    const sign = side === 'left' ? -1 : 1;
    const span = 2.0;
    const rootChord = 0.8;
    const tipChord = 0.4;
    const thickness = 0.04;
    const steps = 6;

    const topPath = [];
    const botPath = [];
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const y = sign * t * span;
      const chord = rootChord + (tipChord - rootChord) * t;
      const midZ = 4.2 - chord / 2;
      const h = thickness * (1 - 0.3 * t);
      topPath.push(new BABYLON.Vector3(y, 0.2 + h, midZ));
      botPath.push(new BABYLON.Vector3(y, 0.2 - h, midZ));
    }

    const stab = BABYLON.MeshBuilder.CreateRibbon(name, {
      pathArray: [topPath, botPath],
      closePath: false,
      sideOrientation: BABYLON.Mesh.DOUBLESIDE,
    }, scene);
    stab.material = fuselageMat;
    stab.parent = body;
    return stab;
  }

  createHStab('hStabLeft', 'left');
  createHStab('hStabRight', 'right');

  // === Elevator — box at trailing edge of horizontal stabilizer ===
  const elevatorHinge = new BABYLON.TransformNode('elevatorHinge', scene);
  elevatorHinge.position.set(0, 0.2, 4.5);
  elevatorHinge.parent = body;
  const elevator = BABYLON.MeshBuilder.CreateBox('elevator', {
    width: 3.6, height: 0.05, depth: 0.35
  }, scene);
  elevator.position.set(0, 0, 0.175);
  elevator.material = surfaceMat;
  elevator.parent = elevatorHinge;

  // === Vertical Stabilizer — tapered box ===
  const vStab = BABYLON.MeshBuilder.CreateBox('vStab', {
    width: 0.08, height: 1.8, depth: 1.2
  }, scene);
  vStab.position.set(0, 1.1, 3.8);
  vStab.material = fuselageMat;
  vStab.parent = body;

  // === Rudder — box at trailing edge of vertical stabilizer ===
  const rudderHinge = new BABYLON.TransformNode('rudderHinge', scene);
  rudderHinge.position.set(0, 1.1, 4.4);
  rudderHinge.parent = body;
  const rudder = BABYLON.MeshBuilder.CreateBox('rudder', {
    width: 0.06, height: 1.6, depth: 0.35
  }, scene);
  rudder.position.set(0, 0, 0.175);
  rudder.material = surfaceMat;
  rudder.parent = rudderHinge;

  // === Landing Gear — 3 assemblies ===
  function createGearAssembly(name, pos) {
    const group = new BABYLON.TransformNode(name, scene);
    group.position.set(pos.x, pos.y, pos.z);
    group.parent = body;

    // Strut
    const strut = BABYLON.MeshBuilder.CreateCylinder(name + 'Strut', {
      diameter: 0.08, height: 1.0, tessellation: 8
    }, scene);
    strut.position.y = -0.5;
    strut.material = strutMat;
    strut.parent = group;

    // Wheel
    const wheel = BABYLON.MeshBuilder.CreateCylinder(name + 'Wheel', {
      diameter: 0.4, height: 0.15, tessellation: 12
    }, scene);
    wheel.rotation.z = Math.PI / 2;
    wheel.position.y = -1.0;
    wheel.material = wheelMat;
    wheel.parent = group;

    return group;
  }

  const noseGearGroup = createGearAssembly('noseGear', { x: 0, y: -0.3, z: -3.0 });
  const leftGearGroup = createGearAssembly('leftGear', { x: -1.5, y: -0.3, z: 0 });
  const rightGearGroup = createGearAssembly('rightGear', { x: 1.5, y: -0.3, z: 0 });

  // === Wingtip Transform Nodes for vapor trails ===
  const leftWingTip = new BABYLON.TransformNode('leftWingTip', scene);
  leftWingTip.position.set(-6, -0.1, -0.5);
  leftWingTip.parent = body;

  const rightWingTip = new BABYLON.TransformNode('rightWingTip', scene);
  rightWingTip.position.set(6, -0.1, -0.5);
  rightWingTip.parent = body;

  // === Prop Disc — spinning translucent disc at nose ===
  const propDisc = BABYLON.MeshBuilder.CreateDisc('propDisc', { radius: 0.8, tessellation: 24 }, scene);
  propDisc.position.set(0, 0, -5.0);
  propDisc.rotation.x = Math.PI / 2;
  propDisc.parent = body;
  const propMat = new BABYLON.StandardMaterial('propMat', scene);
  propMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
  propMat.alpha = 0.15;
  propMat.backFaceCulling = false;
  propDisc.material = propMat;

  // Render aircraft on top of terrain (same group as runway)
  root.getChildMeshes().forEach(m => m.renderingGroupId = 1);

  root.rotationQuaternion = new BABYLON.Quaternion(0, 0, 0, 1);

  return {
    root,
    surfaces: {
      leftAileron,
      rightAileron,
      elevator: elevatorHinge,
      rudder: rudderHinge,
      noseGearGroup,
      leftGearGroup,
      rightGearGroup,
      leftWingTip,
      rightWingTip,
      propDisc,
    }
  };
}

// ============================================================
// Chase Camera
// ============================================================
class ChaseCamera {
  constructor(scene) {
    this.camera = new BABYLON.FreeCamera('chase', BABYLON.Vector3.Zero(), scene);
    this.camera.inputs.clear(); // prevent Babylon's default WASD/arrow controls
    this.camera.minZ = 0.5;
    this.camera.maxZ = 10000;
    this.camera.fov = 1.0;

    // Offset in aircraft local space: 5m above, 20m behind (+Z = behind)
    this.offset = new BABYLON.Vector3(0, 5, 20);

    this.smoothedPosition = null;
    this.smoothedTarget = null;
    this.alpha = 0.08;
    this.baseDt = 1 / 60;
  }

  update(aircraftMesh, dt) {
    const meshQ = aircraftMesh.rotationQuaternion;
    const meshPos = aircraftMesh.position;

    // Rotate offset by aircraft orientation to get desired world position
    const offsetWorld = new BABYLON.Vector3(0, 0, 0);
    const rotMatrix = new BABYLON.Matrix();
    BABYLON.Matrix.FromQuaternionToRef(meshQ, rotMatrix);
    BABYLON.Vector3.TransformCoordinatesToRef(this.offset, rotMatrix, offsetWorld);

    const desiredPos = meshPos.add(offsetWorld);
    const desiredTarget = meshPos.clone();

    // Initialize on first frame
    if (!this.smoothedPosition) {
      this.smoothedPosition = desiredPos.clone();
      this.smoothedTarget = desiredTarget.clone();
    }

    // Frame-rate adjusted lerp alpha
    const a = 1 - Math.pow(1 - this.alpha, dt / this.baseDt);

    BABYLON.Vector3.LerpToRef(this.smoothedPosition, desiredPos, a, this.smoothedPosition);
    BABYLON.Vector3.LerpToRef(this.smoothedTarget, desiredTarget, a, this.smoothedTarget);

    // Clamp camera above terrain (never underground)
    const terrainH = getTerrainHeightBounded(this.smoothedPosition.x, this.smoothedPosition.z);
    if (this.smoothedPosition.y < terrainH + 2) this.smoothedPosition.y = terrainH + 2;

    this.camera.position.copyFrom(this.smoothedPosition);
    this.camera.setTarget(this.smoothedTarget);
  }
}

// ============================================================
// Game Loop — Babylon engine render loop with fixed timestep physics
// ============================================================
const FIXED_DT = 1 / 60;
const MAX_FRAME_DT = 0.1;

const model = new FlightModel();
model.getGroundHeight = getTerrainHeightBounded;
const input = new InputHandler();

const canvas = document.getElementById('renderCanvas');
const engine = new BABYLON.Engine(canvas, true, { stencil: true });
const { scene, shadowGen, terrainManager, cloudPlane } = createScene(engine);
const { root: aircraftMesh, surfaces } = createAircraftMesh(scene);
const chaseCamera = new ChaseCamera(scene);
scene.activeCamera = chaseCamera.camera;

// Rendering Pipeline — bloom, FXAA, tone mapping
const pipeline = new BABYLON.DefaultRenderingPipeline('pipeline', true, scene, [chaseCamera.camera]);
pipeline.fxaaEnabled = true;
pipeline.bloomEnabled = true;
pipeline.bloomThreshold = 0.8;
pipeline.bloomWeight = 0.3;
pipeline.bloomKernel = 64;
pipeline.bloomScale = 0.5;
pipeline.imageProcessingEnabled = true;
pipeline.imageProcessing.toneMappingEnabled = true;
pipeline.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
pipeline.imageProcessing.exposure = 1.2;
pipeline.imageProcessing.contrast = 1.1;

// Register aircraft as shadow caster
aircraftMesh.getChildMeshes().forEach(m => shadowGen.addShadowCaster(m));

// Wingtip vapor trails
const trailMat = new BABYLON.StandardMaterial('trailMat', scene);
trailMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
trailMat.emissiveColor = new BABYLON.Color3(0.8, 0.8, 0.8);
trailMat.alpha = 0;
trailMat.backFaceCulling = false;

const leftTrail = new BABYLON.TrailMesh('leftTrail', surfaces.leftWingTip, scene, 0.15, 90, true);
leftTrail.material = trailMat;
const rightTrail = new BABYLON.TrailMesh('rightTrail', surfaces.rightWingTip, scene, 0.15, 90, true);
rightTrail.material = trailMat;

let lastTime = null;
let accumulator = 0;

// Previous state for interpolation (eliminates fixed-timestep stutter)
let prevPosition = new Vec3(model.position.x, model.position.y, model.position.z);
let prevOrientation = model.orientation.clone();

// Restart function
function restart() {
  model.reset();
  model.position.y = getTerrainHeightBounded(0, 0);
  accumulator = 0;
  lastTime = null;
  prevPosition.set(0, model.position.y, 0);
  prevOrientation = new Quat(0, 0, 0, 1);
  // Reset camera smoothing
  chaseCamera.smoothedPosition = null;
  chaseCamera.smoothedTarget = null;
  // Reset gear mesh rotations
  surfaces.noseGearGroup.rotation.x = 0;
  surfaces.leftGearGroup.rotation.z = 0;
  surfaces.rightGearGroup.rotation.z = 0;
  // Reset control surfaces
  surfaces.leftAileron.rotation.x = 0;
  surfaces.rightAileron.rotation.x = 0;
  surfaces.elevator.rotation.x = 0;
  surfaces.rudder.rotation.y = 0;
  // Reset prop disc
  surfaces.propDisc.rotation.z = 0;
  // Reset vapor trails
  trailMat.alpha = 0;
}

let paused = false;

// Initialize flight HUD DOM pools
initFlightHUD();

// Listen for R key to restart after crash, P/Escape to toggle pause
window.addEventListener('keydown', (e) => {
  if (e.code === 'KeyR' && model.crashed) {
    restart();
    paused = false;
  }
  if (e.code === 'KeyP' || e.code === 'Escape') {
    if (!model.crashed) {
      paused = !paused;
      if (!paused) lastTime = null; // reset dt so no huge jump after unpause
    }
  }
  if (e.code === 'Backquote') {
    debugPanelVisible = !debugPanelVisible;
    document.getElementById('hud').className = debugPanelVisible ? 'visible' : '';
  }
  // Toggle landing gear (only when airborne)
  if (e.code === 'KeyG' && !model.crashed && !model.onGround) {
    model.gearDown = !model.gearDown;
  }
  // Toggle auto-level
  if (e.code === 'KeyL' && !model.crashed) {
    model.autoLevel = !model.autoLevel;
  }
});

engine.runRenderLoop(() => {
  // Pause overlay
  document.getElementById('pause-overlay').className = paused ? 'visible' : '';

  const now = performance.now();
  if (lastTime === null) { lastTime = now; return; }

  let frameDt = (now - lastTime) / 1000;
  lastTime = now;

  if (frameDt > MAX_FRAME_DT) frameDt = MAX_FRAME_DT;

  // When paused, still render but skip physics and input
  if (paused) { scene.render(); return; }

  // 1. Input — skip when crashed
  if (!model.crashed) {
    input.update(frameDt, model);
  }

  // 2. Fixed timestep physics with state snapshots for interpolation
  accumulator += frameDt;
  while (accumulator >= FIXED_DT) {
    prevPosition.set(model.position.x, model.position.y, model.position.z);
    prevOrientation = model.orientation.clone();
    model.stepPhysics(FIXED_DT);
    accumulator -= FIXED_DT;
  }

  // 3. Interpolate visual mesh between previous and current physics state
  const alpha = accumulator / FIXED_DT;
  aircraftMesh.position.set(
    prevPosition.x + (model.position.x - prevPosition.x) * alpha,
    prevPosition.y + (model.position.y - prevPosition.y) * alpha,
    prevPosition.z + (model.position.z - prevPosition.z) * alpha
  );
  // Slerp orientation
  const po = prevOrientation, co = model.orientation;
  let dot = po.x * co.x + po.y * co.y + po.z * co.z + po.w * co.w;
  const sign = dot < 0 ? -1 : 1;
  dot *= sign;
  // For very small angles, use lerp to avoid division by zero
  let s0, s1;
  if (dot > 0.9995) {
    s0 = 1 - alpha;
    s1 = alpha * sign;
  } else {
    const omega = Math.acos(dot);
    const sinOmega = Math.sin(omega);
    s0 = Math.sin((1 - alpha) * omega) / sinOmega;
    s1 = Math.sin(alpha * omega) / sinOmega * sign;
  }
  aircraftMesh.rotationQuaternion.set(
    s0 * po.x + s1 * co.x,
    s0 * po.y + s1 * co.y,
    s0 * po.z + s1 * co.z,
    s0 * po.w + s1 * co.w
  );

  // 4. Control surface deflection
  const AILERON_MAX = 15 * Math.PI / 180;
  const ELEVATOR_MAX = 20 * Math.PI / 180;
  const RUDDER_MAX = 20 * Math.PI / 180;

  surfaces.rightAileron.rotation.x = -input.smoothRoll * AILERON_MAX;
  surfaces.leftAileron.rotation.x = input.smoothRoll * AILERON_MAX;
  surfaces.elevator.rotation.x = input.smoothPitch * ELEVATOR_MAX;
  surfaces.rudder.rotation.y = input.smoothYaw * RUDDER_MAX;

  // 5. Landing gear animation
  const GEAR_ANIM_SPEED = 0.5; // full travel in 2 seconds
  if (model.gearDown && model.gearProgress > 0) {
    model.gearProgress = Math.max(0, model.gearProgress - GEAR_ANIM_SPEED * frameDt);
  } else if (!model.gearDown && model.gearProgress < 1) {
    model.gearProgress = Math.min(1, model.gearProgress + GEAR_ANIM_SPEED * frameDt);
  }
  surfaces.noseGearGroup.rotation.x = model.gearProgress * Math.PI / 2;
  surfaces.leftGearGroup.rotation.z = model.gearProgress * Math.PI / 2;
  surfaces.rightGearGroup.rotation.z = -model.gearProgress * Math.PI / 2;

  // 6. Prop disc spin
  surfaces.propDisc.rotation.z += model.throttle * 80 * frameDt;
  surfaces.propDisc.material.alpha = model.throttle > 0.05 ? 0.12 + model.throttle * 0.08 : 0;

  // 7. Wingtip vapor trails — visible during high-G maneuvers
  const gLoad = model.airspeed > 10 ?
    Math.abs(model.angularVelocity.x * model.airspeed + model.angularVelocity.z * model.airspeed) / 9.81 : 0;
  const targetAlpha = gLoad > 2.0 ? Math.min(0.4, (gLoad - 2.0) * 0.15) : 0;
  trailMat.alpha += (targetAlpha - trailMat.alpha) * 3.0 * frameDt;

  // 8. Terrain chunk loading
  terrainManager.update(aircraftMesh.position.x, aircraftMesh.position.z);

  // 9. Boundary warning
  const distFromOrigin = Math.sqrt(model.position.x ** 2 + model.position.z ** 2);
  document.getElementById('boundary-warning').className = distFromOrigin > 23000 ? 'visible' : '';

  // 10. Cloud layer follows camera
  cloudPlane.position.x = chaseCamera.camera.position.x;
  cloudPlane.position.z = chaseCamera.camera.position.z;

  // 11. Chase camera
  chaseCamera.update(aircraftMesh, frameDt);

  // 12. HUD
  updateHUD(model);

  // 13. Render
  scene.render();
});

window.addEventListener('resize', () => engine.resize());
</script>
</body>
</html>
